<channel version="3.5.2">
  <id>4551d29a-cbd6-4d8e-8b7f-3ddc27b8c6ad</id>
  <nextMetaDataId>4</nextMetaDataId>
  <name>Rest Client DUP</name>
  <description></description>
  <revision>4</revision>
  <sourceConnector version="3.5.2">
    <metaDataId>0</metaDataId>
    <name>sourceConnector</name>
    <properties class="com.mirth.connect.connectors.vm.VmReceiverProperties" version="3.5.2">
      <pluginProperties/>
      <sourceConnectorProperties version="3.5.2">
        <responseVariable>None</responseVariable>
        <respondAfterProcessing>true</respondAfterProcessing>
        <processBatch>false</processBatch>
        <firstResponse>false</firstResponse>
        <processingThreads>1</processingThreads>
        <resourceIds class="linked-hash-map">
          <entry>
            <string>Default Resource</string>
            <string>[Default Resource]</string>
          </entry>
        </resourceIds>
        <queueBufferSize>1000</queueBufferSize>
      </sourceConnectorProperties>
    </properties>
    <transformer version="3.5.2">
      <elements>
        <com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
          <name></name>
          <sequenceNumber>0</sequenceNumber>
          <script>var currMessage = JSON.parse(connectorMessage.getRawData());
logger.debug(&quot;Source Transformer:&quot; + JSON.stringify(currMessage));

var currBatchSeq = currMessage.batchSeq;
var currEpisodeID = currMessage.episodeID;

channelMap.put(&apos;BatchSeq&apos;, currBatchSeq);
channelMap.put(&apos;EpisodeID&apos;, currEpisodeID);

msg = JSON.stringify(currMessage.Patient);</script>
        </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
      </elements>
      <inboundTemplate encoding="base64"></inboundTemplate>
      <outboundTemplate encoding="base64"></outboundTemplate>
      <inboundDataType>DELIMITED</inboundDataType>
      <outboundDataType>RAW</outboundDataType>
      <inboundProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDataTypeProperties" version="3.5.2">
        <serializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedSerializationProperties" version="3.5.2">
          <columnDelimiter>,</columnDelimiter>
          <recordDelimiter>\n</recordDelimiter>
          <quoteToken>&quot;</quoteToken>
          <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
          <quoteEscapeToken>\</quoteEscapeToken>
          <numberedRows>false</numberedRows>
          <ignoreCR>true</ignoreCR>
        </serializationProperties>
        <deserializationProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedDeserializationProperties" version="3.5.2">
          <columnDelimiter>,</columnDelimiter>
          <recordDelimiter>\n</recordDelimiter>
          <quoteToken>&quot;</quoteToken>
          <escapeWithDoubleQuote>true</escapeWithDoubleQuote>
          <quoteEscapeToken>\</quoteEscapeToken>
        </deserializationProperties>
        <batchProperties class="com.mirth.connect.plugins.datatypes.delimited.DelimitedBatchProperties" version="3.5.2">
          <splitType>Record</splitType>
          <batchSkipRecords>0</batchSkipRecords>
          <batchMessageDelimiter></batchMessageDelimiter>
          <batchMessageDelimiterIncluded>false</batchMessageDelimiterIncluded>
          <batchGroupingColumn></batchGroupingColumn>
          <batchScript></batchScript>
        </batchProperties>
      </inboundProperties>
      <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.5.2">
        <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.5.2">
          <splitType>JavaScript</splitType>
          <batchScript></batchScript>
        </batchProperties>
      </outboundProperties>
    </transformer>
    <filter version="3.5.2">
      <elements/>
    </filter>
    <transportName>Channel Reader</transportName>
    <mode>SOURCE</mode>
    <enabled>true</enabled>
    <waitForPrevious>true</waitForPrevious>
  </sourceConnector>
  <destinationConnectors>
    <connector version="3.5.2">
      <metaDataId>2</metaDataId>
      <name>RippleDown</name>
      <properties class="com.mirth.connect.connectors.http.HttpDispatcherProperties" version="3.5.2">
        <pluginProperties/>
        <destinationConnectorProperties version="3.5.2">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <host>${CDS_URL}HUS_SEPSIS2</host>
        <useProxyServer>false</useProxyServer>
        <proxyAddress></proxyAddress>
        <proxyPort></proxyPort>
        <method>post</method>
        <headers class="linked-hash-map"/>
        <parameters class="linked-hash-map"/>
        <responseXmlBody>false</responseXmlBody>
        <responseParseMultipart>true</responseParseMultipart>
        <responseIncludeMetadata>false</responseIncludeMetadata>
        <responseBinaryMimeTypes>application/.*(?&lt;!json|xml)$|image/.*|video/.*|audio/.*</responseBinaryMimeTypes>
        <responseBinaryMimeTypesRegex>false</responseBinaryMimeTypesRegex>
        <multipart>false</multipart>
        <useAuthentication>false</useAuthentication>
        <authenticationType>Basic</authenticationType>
        <usePreemptiveAuthentication>false</usePreemptiveAuthentication>
        <username></username>
        <password></password>
        <content>${message.encodedData}</content>
        <contentType>application/json</contentType>
        <dataTypeBinary>false</dataTypeBinary>
        <charset>UTF-8</charset>
        <socketTimeout>10000</socketTimeout>
      </properties>
      <transformer version="3.5.2">
        <elements>
          <com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
            <name>Log Message</name>
            <sequenceNumber>0</sequenceNumber>
            <script>logger.info(msg);</script>
          </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
        </elements>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>JSON</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.5.2">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.5.2">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.json.JSONDataTypeProperties" version="3.5.2">
          <batchProperties class="com.mirth.connect.plugins.datatypes.json.JSONBatchProperties" version="3.5.2">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="3.5.2">
        <elements>
          <com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
            <name>Process Response</name>
            <sequenceNumber>0</sequenceNumber>
            <script>/*var responseStatus = response.getNewMessageStatus();
              logger.trace(&quot;Response from REST call: &quot; + responseStatus);

              var currBatchSeq = channelMap.get(&apos;BatchSeq&apos;);
		    var currEpisodeID = channelMap.get(&apos;EpisodeID&apos;);

              Update_CDS_Status(responseStatus, currBatchSeq, currEpisodeID);

              var responseMessage = response.getMessage();

              try {
                var responseObject = JSON.parse(responseMessage);
                if (responseObject &amp;&amp; typeof responseObject === &quot;object&quot;){
                  var caseId = responseObject.caseId;
                  var report = responseObject.report;

                  if (responseStatus == &quot;SENT&quot;) {
                    var dbConn = Get_CDS_Connection();

                    var episodeId = new java.util.ArrayList();
                    episodeId.add(caseId);
                    var latestEpisode = get_latest_episode_for_episodeID(episodeId);
                    if (latestEpisode.next()) {
                      var patientID = latestEpisode.getString(&quot;PatientID&quot;);
                      var patientFamilyName = latestEpisode.getString(&quot;PatientFamilyName&quot;);
                      var patientGivenName = latestEpisode.getString(&quot;PatientGivenName&quot;);
                      var episodeDateTime = latestEpisode.getString(&quot;EpisodeDateTime&quot;);
                      var episodeId = caseId;
                      var testLISCode = &quot;RippleDown report&quot;;
                      var testLISName = &quot;RippleDown report&quot;;
                      var testValue = report;
                      var processed = &quot;Y&quot;;
                      var result = insert_rippleDown_response(patientID, patientFamilyName, patientGivenName, episodeId, episodeDateTime, testLISCode, testLISName, testValue, processed);
                    }
                  }
                }
              } catch (exception) {
                logger.error(exception);
              }
              */</script>
          </com.mirth.connect.plugins.javascriptstep.JavaScriptStep>
        </elements>
        <inboundTemplate encoding="base64"></inboundTemplate>
        <outboundTemplate encoding="base64"></outboundTemplate>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.5.2">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.5.2">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.5.2">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.5.2">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="3.5.2">
        <elements/>
      </filter>
      <transportName>HTTP Sender</transportName>
      <mode>DESTINATION</mode>
      <enabled>true</enabled>
      <waitForPrevious>true</waitForPrevious>
    </connector>
    <connector version="3.5.2">
      <metaDataId>3</metaDataId>
      <name>Destination 1</name>
      <properties class="com.mirth.connect.connectors.vm.VmDispatcherProperties" version="3.5.2">
        <pluginProperties/>
        <destinationConnectorProperties version="3.5.2">
          <queueEnabled>false</queueEnabled>
          <sendFirst>false</sendFirst>
          <retryIntervalMillis>10000</retryIntervalMillis>
          <regenerateTemplate>false</regenerateTemplate>
          <retryCount>0</retryCount>
          <rotate>false</rotate>
          <includeFilterTransformer>false</includeFilterTransformer>
          <threadCount>1</threadCount>
          <threadAssignmentVariable></threadAssignmentVariable>
          <validateResponse>false</validateResponse>
          <resourceIds class="linked-hash-map">
            <entry>
              <string>Default Resource</string>
              <string>[Default Resource]</string>
            </entry>
          </resourceIds>
          <queueBufferSize>1000</queueBufferSize>
          <reattachAttachments>true</reattachAttachments>
        </destinationConnectorProperties>
        <channelId>none</channelId>
        <channelTemplate>${message.encodedData}</channelTemplate>
        <mapVariables/>
      </properties>
      <transformer version="3.5.2">
        <elements/>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.5.2">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.5.2">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.5.2">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.5.2">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </transformer>
      <responseTransformer version="3.5.2">
        <elements/>
        <inboundDataType>RAW</inboundDataType>
        <outboundDataType>RAW</outboundDataType>
        <inboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.5.2">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.5.2">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </inboundProperties>
        <outboundProperties class="com.mirth.connect.plugins.datatypes.raw.RawDataTypeProperties" version="3.5.2">
          <batchProperties class="com.mirth.connect.plugins.datatypes.raw.RawBatchProperties" version="3.5.2">
            <splitType>JavaScript</splitType>
            <batchScript></batchScript>
          </batchProperties>
        </outboundProperties>
      </responseTransformer>
      <filter version="3.5.2">
        <elements/>
      </filter>
      <transportName>Channel Writer</transportName>
      <mode>DESTINATION</mode>
      <enabled>false</enabled>
      <waitForPrevious>true</waitForPrevious>
    </connector>
  </destinationConnectors>
  <preprocessingScript>// Modify the message variable below to pre process data
return message;</preprocessingScript>
  <postprocessingScript>// This script executes once after a message has been processed
// Responses returned from here will be stored as &quot;Postprocessor&quot; in the response map
return;</postprocessingScript>
  <deployScript>// This script executes once when the channel is deployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</deployScript>
  <undeployScript>// This script executes once when the channel is undeployed
// You only have access to the globalMap and globalChannelMap here to persist data
return;</undeployScript>
  <properties version="3.5.2">
    <clearGlobalChannelMap>true</clearGlobalChannelMap>
    <messageStorageMode>PRODUCTION</messageStorageMode>
    <encryptData>false</encryptData>
    <removeContentOnCompletion>false</removeContentOnCompletion>
    <removeOnlyFilteredOnCompletion>false</removeOnlyFilteredOnCompletion>
    <removeAttachmentsOnCompletion>false</removeAttachmentsOnCompletion>
    <initialState>STOPPED</initialState>
    <storeAttachments>false</storeAttachments>
    <metaDataColumns>
      <metaDataColumn>
        <name>SOURCE</name>
        <type>STRING</type>
        <mappingName>mirth_source</mappingName>
      </metaDataColumn>
      <metaDataColumn>
        <name>TYPE</name>
        <type>STRING</type>
        <mappingName>mirth_type</mappingName>
      </metaDataColumn>
    </metaDataColumns>
    <attachmentProperties version="3.5.2">
      <type>None</type>
      <properties/>
    </attachmentProperties>
    <resourceIds class="linked-hash-map">
      <entry>
        <string>Default Resource</string>
        <string>[Default Resource]</string>
      </entry>
    </resourceIds>
  </properties>
  <exportData>
    <metadata>
      <enabled>true</enabled>
      <lastModified>
        <time>1558435176358</time>
        <timezone>Europe/Paris</timezone>
      </lastModified>
      <pruningSettings>
        <pruneMetaDataDays>1</pruneMetaDataDays>
        <pruneContentDays>1</pruneContentDays>
        <archiveEnabled>false</archiveEnabled>
      </pruningSettings>
    </metadata>
    <codeTemplateLibraries>
      <codeTemplateLibrary version="3.5.2">
        <id>be8c75bc-37f7-48dc-a26e-b9e50c6f285a</id>
        <name>PKS CDS</name>
        <revision>18</revision>
        <lastModified>
          <time>1558434133968</time>
          <timezone>Europe/Paris</timezone>
        </lastModified>
        <description></description>
        <includeNewChannels>true</includeNewChannels>
        <enabledChannelIds>
          <string>00680d42-b755-42ec-9957-08ae467c47c9</string>
          <string>6df4f01c-e2ee-400b-8f23-547df6db1358</string>
          <string>abea2846-873a-40a1-ad88-e190ca72c538</string>
          <string>dd25385a-527d-40a7-9228-36ea863aaf70</string>
          <string>98945d85-1350-4c5c-9344-918fa9936d68</string>
          <string>e587470e-5f72-4c81-842e-3e1339eb1201</string>
          <string>d372baf5-13c1-4fa5-87e4-4381de48fdc5</string>
        </enabledChannelIds>
        <disabledChannelIds/>
        <codeTemplates>
          <codeTemplate version="3.5.2">
            <id>ecf96a6d-b5d6-4c13-b16a-c31a253cb9bb</id>
            <name>Get_CDS_Connection</name>
            <revision>1</revision>
            <lastModified>
              <time>1550770641609</time>
              <timezone>Europe/Paris</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>/**
JavaScript function to centralise creation of a database connection. The
connection won&apos;t be open, the caller still needs to do this but all constants
will be instantiated here

@return dbConn returns an instance of a returns a new DatabaseConnection object
*/
function Get_CDS_Connection() {
var dbConn = $gc(&apos;dbConn&apos;);

if (!dbConn || dbConn.getConnection().isClosed()) {
var dbConn = DatabaseConnectionFactory.createDatabaseConnection($(&apos;CDS_Driver_Name&apos;), $(&apos;CDS_DB_URL&apos;), $(&apos;CDS_DB_UserName&apos;), $(&apos;CDS_DB_Password&apos;));
$gc(&apos;dbConn&apos;, dbConn);
}

return dbConn;
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.5.2">
            <id>8e116c30-555e-4d03-97c8-0dd649526eda</id>
            <name>Get_Latest_Episode_For_EpisodeID</name>
            <revision>1</revision>
            <lastModified>
              <time>1550770641427</time>
              <timezone>Europe/Paris</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>
				function get_latest_episode_for_episodeID(episodeIDList) {
				  var dbConn = Get_CDS_Connection();
				  var sql = &quot;SELECT * FROM cds_data WHERE EpisodeID = ? ORDER BY EpisodeDateTime DESC LIMIT 1&quot;;
				  var latestEpisode = &quot;&quot;;
				  	try {
				  		var latestEpisode = dbConn.executeCachedQuery(sql, episodeIDList);
				  	} catch (exception) {
				  		logger.error(&quot;Error when inserting data: &quot; + exception);
				  	} finally {
				  		dbConn.close();
				  	}
				  return latestEpisode;
				}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.5.2">
            <id>5c27c0de-56d5-4eb9-bc17-a5ad0805f34a</id>
            <name>Insert_CDS_Data</name>
            <revision>1</revision>
            <lastModified>
              <time>1550770641248</time>
              <timezone>Europe/Paris</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>// Insert CDS data into rd_staging.cds_data from flat file source

function Insert_CDS_Data(PatientID,PatientFamilyName,PatientGivenName,PatientTitle,PatientDOB,PatientSex,PatientStreetAddress,PatientCity,PatientPostalCode,PatientState,PatientCountry,PatientStatus,PatientPregnancyFlag,PatientFastingFlag,EpisodeID,EpisodeOrderedTests, EpisodeDateTime,EpisodeClinicalNotes,AccountType,AccountClass,BillTo,BillingAddress,PatientPublicHealthIdentifier,EpisodePublicScheduleCode,PatientPrivateHealthFundName,PatientPrivateHealthFundID,ReqPhysicianID,ReqPhysicianName,ReqPhysicianSpeciality,ReqPhysicianDeliveryAddress,SugeryName,SurgeryCode,SurgeryAddress,SurgeryPostalCode,CopyPhysicianIDList,CopyPhysicianNameList,PanelIndicator,PanelID,PanelName,SampleID,SampleFluidType,SampleOriginLocation,SampleOriginSubLocation,SampleCollectionDateTime,SampleCollectionMethod,TestSiteSampleReceivedDateTime,TestLISCode,TestLISName,TestValue,TestNormalRange,TestUnits,TestPriority,TestDepartment,TestInstrument,TestRequestSite,TestSite,TestType,AbnormalFlag,TestOrderedDateTime,TestAnalyzerCompletionDateTime,TestResultFirstReviewedDateTime,TestResultReleasedDateTime)
{

	try {
		var dbConn = Get_CDS_Connection();

		var _returnValue = 1;
		var _sqlQuery = &quot;CALL rd_staging.rdInsCDSData (&apos;&quot; + PatientID + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + PatientFamilyName + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + PatientGivenName + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + PatientTitle + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + PatientDOB + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + PatientSex + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + PatientStreetAddress + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + PatientCity + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + PatientPostalCode + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + PatientState + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + PatientCountry + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + PatientStatus + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + PatientPregnancyFlag + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + PatientFastingFlag + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + EpisodeID + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + EpisodeOrderedTests + &quot;&apos;&quot;
									+ &quot;, &quot; + buildStringIfNotNull(EpisodeDateTime) +&quot;, \
									&apos;&quot; + EpisodeClinicalNotes + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + AccountType + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + AccountClass + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + BillTo + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + BillingAddress + &quot;&apos;&quot;+&quot;, \
									&apos;&quot; + PatientPublicHealthIdentifier + &quot;&apos;, \
									&apos;&quot; + EpisodePublicScheduleCode + &quot;&apos;, \
									&apos;&quot; + PatientPrivateHealthFundName + &quot;&apos;, \
									&apos;&quot; + PatientPrivateHealthFundID + &quot;&apos;, \
									&apos;&quot; + ReqPhysicianID + &quot;&apos;, \
									&apos;&quot; + ReqPhysicianName + &quot;&apos;, \
									&apos;&quot; + ReqPhysicianSpeciality + &quot;&apos;, \
									&apos;&quot; + ReqPhysicianDeliveryAddress + &quot;&apos;, \
									&apos;&quot; + SugeryName + &quot;&apos;, \
									&apos;&quot; + SurgeryCode + &quot;&apos;, \
									&apos;&quot; + SurgeryAddress + &quot;&apos;, \
									&apos;&quot; + SurgeryPostalCode + &quot;&apos;, \
									&apos;&quot; + CopyPhysicianIDList + &quot;&apos;, \
									&apos;&quot; + CopyPhysicianNameList + &quot;&apos;, \
									&apos;&quot; + PanelIndicator + &quot;&apos;, \
									&apos;&quot; + PanelID + &quot;&apos;, \
									&apos;&quot; + PanelName + &quot;&apos;, \
									&apos;&quot; + SampleID + &quot;&apos;, \
									&apos;&quot; + SampleFluidType + &quot;&apos;, \
									&apos;&quot; + SampleOriginLocation + &quot;&apos;, \
									&apos;&quot; + SampleOriginSubLocation + &quot;&apos;, \
									&apos;&quot; + SampleCollectionDateTime + &quot;&apos;, \
									&apos;&quot; + SampleCollectionMethod + &quot;&apos;, \
									&apos;&quot; + TestSiteSampleReceivedDateTime + &quot;&apos;, \
									&apos;&quot; + TestLISCode + &quot;&apos;, \
									&apos;&quot; + TestLISName + &quot;&apos;, \
									&apos;&quot; + TestValue + &quot;&apos;, \
									&apos;&quot; + TestNormalRange + &quot;&apos;, \
									&apos;&quot; + TestUnits + &quot;&apos;, \
									&apos;&quot; + TestPriority + &quot;&apos;, \
									&apos;&quot; + TestDepartment + &quot;&apos;, \
									&apos;&quot; + TestInstrument + &quot;&apos;, \
									&apos;&quot; + TestRequestSite + &quot;&apos;, \
									&apos;&quot; + TestSite + &quot;&apos;, \
									&apos;&quot; + TestType + &quot;&apos;, \
									&apos;&quot; + AbnormalFlag + &quot;&apos;, \
									&apos;&quot; + TestOrderedDateTime + &quot;&apos;, \
									&apos;&quot; + TestAnalyzerCompletionDateTime + &quot;&apos;, \
									&apos;&quot; + TestResultFirstReviewedDateTime + &quot;&apos;, \
									&apos;&quot; + TestResultReleasedDateTime + &quot;&apos;)&quot;;

		var _sqlResult = dbConn.executeCachedQuery(_sqlQuery);

		if(_sqlResult.next()) {
			_returnValue = _sqlResult.getInt(1);
			_returnValue = parseInt(_returnValue, 10);
		}
		return _returnValue;
	}
	catch(ex) {
		logger.error(&quot;PKS - Insert_CDS_Data - Exception: &quot;+ ex);
		throw ex;
	}
	finally {
	//	dbConn.close();
	}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.5.2">
            <id>c86e8913-8152-422e-aa5e-f63f7c25d279</id>
            <name>Insert_RippleDown_Response</name>
            <revision>1</revision>
            <lastModified>
              <time>1550770642087</time>
              <timezone>Europe/Paris</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function insert_rippleDown_response(patientID, patientFamilyName, patientGivenName, episodeId, episodeDateTime, testLISCode, testLISName, testValue, processed_YN) {
				      var params = new java.util.ArrayList();
			    	  params.add(patientID);
			    	  params.add(patientFamilyName);
			    	  params.add(patientGivenName);
			    	  params.add(episodeDateTime);
			    	  params.add(episodeId);
			    	  params.add(testLISCode);
			    	  params.add(testLISName);
			    	  params.add(testValue);
			    	  params.add(processed_YN);

				      var dbConn = Get_CDS_Connection();
				      var sql = &quot;INSERT INTO cds_data(PatientID, PatientFamilyName, PatientGivenName, EpisodeDateTime, EpisodeID, testLISCode, TestLISName, TestValue, Processed_YN) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)&quot;;
				      try {
				        var result = dbConn.executeUpdate(sql, params);
				      } catch (exception) {
				        logger.error(&quot;Error when inserting data: &quot; + exception);
				      } finally {
				        dbConn.close();
				      }
				  }</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.5.2">
            <id>519f869e-22ee-4082-8871-acd8b67e9240</id>
            <name>Peek_CDS_Data</name>
            <revision>8</revision>
            <lastModified>
              <time>1554218776442</time>
              <timezone>Europe/Paris</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function Check_Unprocessed_Data() {
	var dbConn = Get_CDS_Connection();
	var rowCount = 0;

	var sqlResult = null;
	try {
		var returnValue = 1;

		var sqlQuery = &quot;call rd_staging.rdSelCDSCount()&quot;;

		logger.trace(&quot;SQL &quot; + sqlQuery);

		sqlResult = dbConn.executeCachedQuery(sqlQuery);
		if (sqlResult.next()) {
			rowCount = sqlResult.getInt(&apos;StatusCode&apos;);
		}
	} finally {
		// Do nothing right now...
		if  (sqlResult != null) {
//			sqlResult.close();
		}
	}
	return rowCount;
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.5.2">
            <id>526bcc34-e16b-48cb-98b6-ca763bad259c</id>
            <name>Records_To_Process</name>
            <revision>8</revision>
            <lastModified>
              <time>1554218776290</time>
              <timezone>Europe/Paris</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function recordsToProcess() {	
	if (Check_Unprocessed_Data() &gt; 0) {
		return true;
	} else {
		return false;
	}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.5.2">
            <id>0f0fea61-ff2b-470f-9452-4d395117df82</id>
            <name>Select_CDS_Data</name>
            <revision>11</revision>
            <lastModified>
              <time>1554414296454</time>
              <timezone>Europe/Paris</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function Select_CDS_Data() {
	var currEpisodeID = &quot;&quot;;
	var currEpisode;
	var currPatientID = &quot;&quot;;
	var currStatus = &quot;&quot;;
	var episodes = [];
	var episodeSize = 0;
	var resp;

	var dbConn = Get_CDS_Connection();
	try {
		var sqlQuery = &quot;call rd_staging.rdSelCDSData()&quot;;

		var sqlResult = dbConn.executeCachedQuery(sqlQuery);
		// We can assume there will always be at least one row, even if there are no records to process
		// Let&apos;s check the result set
		var colCount = sqlResult.getMetaData().getColumnCount();
		// We&apos;re checking for the column count, if it is 2 then it&apos;s just a return code and message

		if (colCount == 2) {
			sqlResult.next();
			logger.trace(&quot;PKS - Select_CDS_Data - Info: &quot; + sqlResult.getString(&quot;Message&quot;));
			return false;
		} else {
			while (sqlResult.next()) {
				tmpEpisodeID		               = sqlResult.getString(&quot;EpisodeID&quot;);
				tmpEpisodeOrderedTests             = sqlResult.getString(&quot;EpisodeOrderedTests&quot;);
				tmpPatientID		               = sqlResult.getString(&quot;PatientID&quot;);
				tmpPatientSurname	               = sqlResult.getString(&quot;PatientFamilyName&quot;);
				tmpEpisodeDateTime   	          = sqlResult.getString(&quot;EpisodeDateTime&quot;);
				tmpPatientDOB		               = sqlResult.getString(&quot;PatientDOB&quot;);
				tmpTestSite		               = sqlResult.getString(&quot;TestSite&quot;);
				tmpPatientFamilyName               = sqlResult.getString(&quot;PatientFamilyName&quot;);
				tmpPatientGivenName                = sqlResult.getString(&quot;PatientGivenName&quot;);
				tmpPatientTitle                    = sqlResult.getString(&quot;PatientTitle&quot;);
				tmpPatientSex                      = sqlResult.getString(&quot;PatientSex&quot;);
				tmpPatientStreetAddress            = sqlResult.getString(&quot;PatientStreetAddress&quot;);
				tmpPatientCity                     = sqlResult.getString(&quot;PatientCity&quot;);
				tmpPatientPostalCode               = sqlResult.getString(&quot;PatientPostalCode&quot;);
				tmpPatientState                    = sqlResult.getString(&quot;PatientState&quot;);
				tmpPatientCountry                  = sqlResult.getString(&quot;PatientCountry&quot;);
				tmpPatientStatus                   = sqlResult.getString(&quot;PatientStatus&quot;);
				tmpPatientPregnancyFlag            = sqlResult.getString(&quot;PatientPregnancyFlag&quot;);
				tmpPatientFastingFlag              = sqlResult.getString(&quot;PatientFastingFlag&quot;);
				tmpEpisodeClinicalNotes            = sqlResult.getString(&quot;EpisodeClinicalNotes&quot;);
				tmpAccountType                     = sqlResult.getString(&quot;AccountType&quot;);
				tmpAccountClass                    = sqlResult.getString(&quot;AccountClass&quot;);
				tmpBillTo                          = sqlResult.getString(&quot;BillTo&quot;);
				tmpBillingAddress                  = sqlResult.getString(&quot;BillingAddress&quot;);
				tmpPatientPublicHealthIdentifier   = sqlResult.getString(&quot;PatientPublicHealthIdentifier&quot;);
				tmpEpisodePublicScheduleCode       = sqlResult.getString(&quot;EpisodePublicScheduleCode&quot;);
				tmpPatientPrivateHealthFundName    = sqlResult.getString(&quot;PatientPrivateHealthFundName&quot;);
				tmpPatientPrivateHealthFundID      = sqlResult.getString(&quot;PatientPrivateHealthFundID&quot;);
				tmpReqPhysicianID                  = sqlResult.getString(&quot;ReqPhysicianID&quot;);
				tmpReqPhysicianName                = sqlResult.getString(&quot;ReqPhysicianName&quot;);
				tmpReqPhysicianSpeciality          = sqlResult.getString(&quot;ReqPhysicianSpeciality&quot;);
				tmpReqPhysicianDeliveryAddress     = sqlResult.getString(&quot;ReqPhysicianDeliveryAddress&quot;);
				tmpSugeryName                      = sqlResult.getString(&quot;SugeryName&quot;);
				tmpSurgeryCode                     = sqlResult.getString(&quot;SurgeryCode&quot;);
				tmpSurgeryAddress                  = sqlResult.getString(&quot;SurgeryAddress&quot;);
				tmpSurgeryPostalCode               = sqlResult.getString(&quot;SurgeryPostalCode&quot;);
				tmpCopyPhysicianIDList             = sqlResult.getString(&quot;CopyPhysicianIDList&quot;);
				tmpCopyPhysicianNameList           = sqlResult.getString(&quot;CopyPhysicianNameList&quot;);
				tmpPanelIndicator                  = sqlResult.getString(&quot;PanelIndicator&quot;);
				tmpPanelID                         = sqlResult.getString(&quot;PanelID&quot;);
				tmpPanelName                       = sqlResult.getString(&quot;PanelName&quot;);
				tmpSampleID                        = sqlResult.getString(&quot;SampleID&quot;);
				tmpSampleFluidType                 = sqlResult.getString(&quot;SampleFluidType&quot;);
				tmpSampleOriginLocation            = sqlResult.getString(&quot;SampleOriginLocation&quot;);
				tmpSampleOriginSubLocation         = sqlResult.getString(&quot;SampleOriginSubLocation&quot;);
				tmpSampleCollectionDateTime        = sqlResult.getString(&quot;SampleCollectionDateTime&quot;);
				tmpSampleCollectionMethod          = sqlResult.getString(&quot;SampleCollectionMethod&quot;);
				tmpTestSiteSampleReceivedDateTime  = sqlResult.getString(&quot;TestSiteSampleReceivedDateTime&quot;);
				tmpTestPriority                    = sqlResult.getString(&quot;TestPriority&quot;);
				tmpTestDepartment                  = sqlResult.getString(&quot;TestDepartment&quot;);
				tmpTestInstrument                  = sqlResult.getString(&quot;TestInstrument&quot;);
				tmpTestRequestSite                 = sqlResult.getString(&quot;TestRequestSite&quot;);
				tmpTestSite                        = sqlResult.getString(&quot;TestSite&quot;);
				tmpTestType                        = sqlResult.getString(&quot;TestType&quot;);
				tmpAbnormalFlag                    = sqlResult.getString(&quot;AbnormalFlag&quot;);
				tmpTestOrderedDateTime             = sqlResult.getString(&quot;TestOrderedDateTime&quot;);
				tmpTestAnalyzerCompletionDateTime  = sqlResult.getString(&quot;TestAnalyzerCompletionDateTime&quot;);
				tmpTestResultFirstReviewedDateTime = sqlResult.getString(&quot;TestResultFirstReviewedDateTime&quot;);
				tmpTestResultReleasedDateTime      = sqlResult.getString(&quot;TestResultReleasedDateTime&quot;);
				tmpEpisodeDate		= DateUtil.getDate(&quot;yyyy-MM-dd HH:mm:ss&quot;, tmpEpisodeDateTime).getTime();

				// Check whether we moved onto a different episode, if we did and it hadn&apos;t already been processed then send a new
				// case...
				if ((tmpEpisodeID != currEpisodeID)) {
					if ($(&apos;cases_from_most_recent_episode_only&apos;) != &apos;true&apos;) {
						if (currEpisodeID != &quot;&quot;) {
							if (currStatus == &quot;N&quot;) {
								var currPatient = {&quot;caseId&quot;: currEpisodeID , site: &quot;&quot;, episodes: []};
								currPatient.episodes = episodes;
								// We&apos;re putting the batchSeq into the JSON message, the destination channel can split this out for use later
								// This is used for updating the records once the records are successfully sent to the web service
								var currMessage = {&quot;batchSeq&quot;: batchSeq, &quot;episodeID&quot;: currEpisodeID, Patient: currPatient};
								var json = JSON.stringify(currPatient);
								logger.trace(&quot;JSON Routing to REST CLIENT: &quot; + json);
								// Send the JSON Object to the Web Service channel
								resp = router.routeMessage(&quot;Rest Client&quot;, JSON.stringify(currMessage));
								if (resp) {
									logger.trace(&quot;Response from REST Channel: &quot; + resp.getMessage());
								}
							}
						}
					}
					
					episodeSize = episodes.push({episodeDate: tmpEpisodeDate,
											episodeId: tmpEpisodeID,
											attributeWithValues: [{externalName: &quot;PID&quot;, name: &quot;PID&quot;, value: tmpPatientID},
															{externalName: &quot;BIRTHDATE&quot;, name: &quot;BIRTHDATE&quot;, value: tmpPatientDOB},
															{externalName: &quot;LASTNAME&quot;, name: &quot;LASTNAME&quot;, value: tmpPatientSurname},
															{externalName: &quot;EpisodeOrderedTests&quot;, name: &quot;EpisodeOrderedTests&quot;, value: tmpEpisodeOrderedTests},
															{externalName: &quot;Site&quot;, name: &quot;Site&quot;, value: tmpTestSite},
															{externalName: &quot;PatientFamilyName&quot;, name : &quot;PatientFamilyName&quot;, value: tmpPatientFamilyName},
															{externalName: &quot;PatientGivenName&quot;, name : &quot;PatientGivenName&quot;, value: tmpPatientGivenName},
															{externalName: &quot;PatientTitle&quot;, name : &quot;PatientTitle&quot;, value: tmpPatientTitle},
															{externalName: &quot;PatientSex&quot;, name : &quot;PatientSex&quot;, value: tmpPatientSex},
															{externalName: &quot;PatientStreetAddress&quot;, name : &quot;PatientStreetAddress&quot;, value: tmpPatientStreetAddress},
															{externalName: &quot;PatientCity&quot;, name : &quot;PatientCity&quot;, value: tmpPatientCity},
															{externalName: &quot;PatientPostalCode&quot;, name : &quot;PatientPostalCode&quot;, value: tmpPatientPostalCode},
															{externalName: &quot;PatientState&quot;, name : &quot;PatientState&quot;, value: tmpPatientState},
															{externalName: &quot;PatientCountry&quot;, name : &quot;PatientCountry&quot;, value: tmpPatientCountry},
															{externalName: &quot;PatientStatus&quot;, name : &quot;PatientStatus&quot;, value: tmpPatientStatus},
															{externalName: &quot;PatientPregnancyFlag&quot;, name : &quot;PatientPregnancyFlag&quot;, value: tmpPatientPregnancyFlag},
															{externalName: &quot;PatientFastingFlag&quot;, name : &quot;PatientFastingFlag&quot;, value: tmpPatientFastingFlag}	,
															{externalName: &quot;PatientGivenName&quot;, name : &quot;externalName&quot;, value: tmpPatientGivenName},
															{externalName: &quot;EpisodeClinicalNotes&quot;, name: &quot;EpisodeClinicalNotes&quot;, value: tmpEpisodeClinicalNotes},
															{externalName: &quot;AccountType&quot;, name: &quot;AccountType&quot;, value: tmpAccountType},
															{externalName: &quot;AccountClass&quot;, name: &quot;AccountClass&quot;, value: tmpAccountClass},
															{externalName: &quot;BillTo&quot;, name: &quot;BillTo&quot;, value: tmpBillTo},
															{externalName: &quot;PatientPublicHealthIdentifier&quot;, name: &quot;PatientPublicHealthIdentifier&quot;, value: tmpPatientPublicHealthIdentifier},
															{externalName: &quot;EpisodePublicScheduleCode&quot;, name: &quot;EpisodePublicScheduleCode&quot;, value: tmpEpisodePublicScheduleCode},
															{externalName: &quot;PatientPrivateHealthFundName&quot;, name: &quot;PatientPrivateHealthFundName&quot;, value: tmpPatientPrivateHealthFundName},
															{externalName: &quot;PatientPrivateHealthFundID&quot;, name: &quot;PatientPrivateHealthFundID&quot;, value: tmpPatientPrivateHealthFundID},
															{externalName: &quot;ReqPhysicianID&quot;, name: &quot;ReqPhysicianID&quot;, value: tmpReqPhysicianID},
															{externalName: &quot;ReqPhysicianName&quot;, name: &quot;ReqPhysicianName&quot;, value: tmpReqPhysicianName},
															{externalName: &quot;ReqPhysicianSpeciality&quot;, name: &quot;ReqPhysicianSpeciality&quot;, value: tmpReqPhysicianSpeciality},
															{externalName: &quot;SugeryName&quot;, name: &quot;SugeryName&quot;, value: tmpSugeryName},
															{externalName: &quot;SurgeryCode&quot;, name: &quot;SurgeryCode&quot;, value: tmpSurgeryCode},
															{externalName: &quot;CopyPhysicianIDList&quot;, name: &quot;CopyPhysicianIDList&quot;, value: tmpCopyPhysicianIDList},
															{externalName: &quot;CopyPhysicianNameList&quot;, name: &quot;CopyPhysicianNameList&quot;, value: tmpCopyPhysicianNameList},
															{externalName: &quot;PanelIndicator&quot;, name: &quot;PanelIndicator&quot;, value: tmpPanelIndicator},
															{externalName: &quot;PanelID&quot;, name: &quot;PanelID&quot;, value: tmpPanelID},
															{externalName: &quot;PanelName&quot;, name: &quot;PanelName&quot;, value: tmpPanelName},
															{externalName: &quot;SampleID&quot;, name: &quot;SampleID&quot;, value: tmpSampleID},
															{externalName: &quot;SampleFluidType&quot;, name: &quot;SampleFluidType&quot;, value: tmpSampleFluidType},
															{externalName: &quot;SampleOriginLocation&quot;, name: &quot;SampleOriginLocation&quot;, value: tmpSampleOriginLocation},
															{externalName: &quot;SampleOriginSubLocation&quot;, name: &quot;SampleOriginSubLocation&quot;, value: tmpSampleOriginSubLocation},
															{externalName: &quot;SampleCollectionDateTime&quot;, name: &quot;SampleCollectionDateTime&quot;, value: tmpSampleCollectionDateTime},
															{externalName: &quot;SampleCollectionMethod&quot;, name: &quot;SampleCollectionMethod&quot;, value: tmpSampleCollectionMethod},
															{externalName: &quot;TestSiteSampleReceivedDateTime&quot;, name: &quot;TestSiteSampleReceivedDateTime&quot;, value: tmpTestSiteSampleReceivedDateTime},
															{externalName: &quot;TestPriority&quot;, name: &quot;TestPriority&quot;, value: tmpTestPriority},
															{externalName: &quot;TestRequestSite&quot;, name: &quot;TestRequestSite&quot;, value: tmpTestRequestSite},
															{externalName: &quot;TestSite&quot;, name: &quot;TestSite&quot;, value: tmpTestSite},
															{externalName: &quot;TestType&quot;, name: &quot;TestType&quot;, value: tmpTestType},
															{externalName: &quot;TestOrderedDateTime&quot;, name: &quot;TestOrderedDateTime&quot;, value: tmpTestOrderedDateTime},
															{externalName: &quot;TestResultReleasedDateTime&quot;, name: &quot;TestResultReleasedDateTime&quot;, value: tmpTestResultReleasedDateTime}]});
				}

				currEpisodeID		= tmpEpisodeID;
				currStatus		= sqlResult.getString(&quot;Processed_YN&quot;);

				tmpTestLISCode		= sqlResult.getString(&quot;TestLISCode&quot;);
				tmpTestLISName		= sqlResult.getString(&quot;TestLISName&quot;);
				tmpTestValue		= sqlResult.getString(&quot;TestValue&quot;);
				tmpTestNormalRange	= sqlResult.getString(&quot;TestNormalRange&quot;);
				tmpTestUnits		= sqlResult.getString(&quot;TestUnits&quot;);
				// batchSeq is only used when processing the records with a status of &quot;N&quot;
				// well actually the records will have a status of &quot;P&quot; for processing
				// but they haven&apos;t already beenprocessed
				batchSeq					= sqlResult.getInt(&quot;BatchSeq&quot;);
				episodes[episodeSize - 1].attributeWithValues.push({externalName: tmpTestLISCode, name: tmpTestLISName, value: tmpTestValue,
														units: tmpTestUnits, range: tmpTestNormalRange});

				/* For testing only. The API fails when sending the acxtual tests from the incoming messages*/
				//episodes[episodeSize - 1].attributeWithValues.push({externalName: &quot;GTT 120m&quot;, name: &quot;GTTP 120min&quot;, value: &quot;6.7&quot;});
				if (tmpPatientID != currPatientID){
					currPatientID = tmpPatientID;
				}
			} //end while
			if (currStatus == &quot;N&quot;) {				
				var currPatient = {&quot;caseId&quot;: currEpisodeID , site: &quot;&quot;, episodes: []};
				currPatient.episodes = episodes;
				var currMessage = {&quot;batchSeq&quot;: batchSeq, &quot;episodeID&quot;: currEpisodeID, Patient: currPatient};
				var json = JSON.stringify(currPatient);
				// Send the JSON Object to the Web Service
				logger.trace(&quot;JSON Routing to REST CLIENT: &quot; + json);
				resp = router.routeMessage(&quot;Rest Client&quot;, JSON.stringify(currMessage));
				if (resp) {
					logger.trace(&quot;Response from REST Channel: &quot; + resp.getMessage());
				}
			}
			return true;
		}
	}
	catch(ex) {
		logger.error(&quot;PKS - Select_CDS_Data - Exception: &quot; + ex);
		throw ex;
	}
	finally {
	//	dbConn.close();
	}

}
</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.5.2">
            <id>41efdcdd-7c59-4f36-b0d0-bf74344772b8</id>
            <name>Select_CDS_Data_Dup</name>
            <revision>5</revision>
            <lastModified>
              <time>1558435239303</time>
              <timezone>Europe/Paris</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function Select_CDS_Data_Dup() {
	var currEpisodeID = &quot;&quot;;
	var currEpisode;
	var currPatientID = &quot;&quot;;
	var currStatus = &quot;&quot;;
	var episodes = [];
	var episodeSize = 0;
	var resp;

	var dbConn = Get_CDS_Connection();
	try {
		var sqlQuery = &quot;call rd_staging.rdSelCDSDataDup_1()&quot;;
channelMap.put(&apos;key&apos;,DateUtil.getCurrentDate(&apos;HHmmss&apos;))
		var sqlResult = dbConn.executeCachedQuery(sqlQuery);
		channelMap.put(&apos;key2&apos;,DateUtil.getCurrentDate(&apos;HHmmss&apos;))
		// We can assume there will always be at least one row, even if there are no records to process
		// Let&apos;s check the result set
		var colCount = sqlResult.getMetaData().getColumnCount();
		// We&apos;re checking for the column count, if it is 2 then it&apos;s just a return code and message

		if (colCount == 2) {
			sqlResult.next();
			logger.trace(&quot;PKS - Select_CDS_Data - Info: &quot; + sqlResult.getString(&quot;Message&quot;));
			return false;
		} else {
			while (sqlResult.next()) {
				tmpEpisodeID		               = sqlResult.getString(&quot;EpisodeID&quot;);
				tmpEpisodeOrderedTests             = sqlResult.getString(&quot;EpisodeOrderedTests&quot;);
				tmpPatientID		               = sqlResult.getString(&quot;PatientID&quot;);
				tmpPatientSurname	               = sqlResult.getString(&quot;PatientFamilyName&quot;);
				tmpEpisodeDateTime   	          = sqlResult.getString(&quot;EpisodeDateTime&quot;);
				tmpPatientDOB		               = sqlResult.getString(&quot;PatientDOB&quot;);
				tmpTestSite		               = sqlResult.getString(&quot;TestSite&quot;);
				tmpPatientFamilyName               = sqlResult.getString(&quot;PatientFamilyName&quot;);
				tmpPatientGivenName                = sqlResult.getString(&quot;PatientGivenName&quot;);
				tmpPatientTitle                    = sqlResult.getString(&quot;PatientTitle&quot;);
				tmpPatientSex                      = sqlResult.getString(&quot;PatientSex&quot;);
				tmpPatientStreetAddress            = sqlResult.getString(&quot;PatientStreetAddress&quot;);
				tmpPatientCity                     = sqlResult.getString(&quot;PatientCity&quot;);
				tmpPatientPostalCode               = sqlResult.getString(&quot;PatientPostalCode&quot;);
				tmpPatientState                    = sqlResult.getString(&quot;PatientState&quot;);
				tmpPatientCountry                  = sqlResult.getString(&quot;PatientCountry&quot;);
				tmpPatientStatus                   = sqlResult.getString(&quot;PatientStatus&quot;);
				tmpPatientPregnancyFlag            = sqlResult.getString(&quot;PatientPregnancyFlag&quot;);
				tmpPatientFastingFlag              = sqlResult.getString(&quot;PatientFastingFlag&quot;);
				tmpEpisodeClinicalNotes            = sqlResult.getString(&quot;EpisodeClinicalNotes&quot;);
				tmpAccountType                     = sqlResult.getString(&quot;AccountType&quot;);
				tmpAccountClass                    = sqlResult.getString(&quot;AccountClass&quot;);
				tmpBillTo                          = sqlResult.getString(&quot;BillTo&quot;);
				tmpBillingAddress                  = sqlResult.getString(&quot;BillingAddress&quot;);
				tmpPatientPublicHealthIdentifier   = sqlResult.getString(&quot;PatientPublicHealthIdentifier&quot;);
				tmpEpisodePublicScheduleCode       = sqlResult.getString(&quot;EpisodePublicScheduleCode&quot;);
				tmpPatientPrivateHealthFundName    = sqlResult.getString(&quot;PatientPrivateHealthFundName&quot;);
				tmpPatientPrivateHealthFundID      = sqlResult.getString(&quot;PatientPrivateHealthFundID&quot;);
				tmpReqPhysicianID                  = sqlResult.getString(&quot;ReqPhysicianID&quot;);
				tmpReqPhysicianName                = sqlResult.getString(&quot;ReqPhysicianName&quot;);
				tmpReqPhysicianSpeciality          = sqlResult.getString(&quot;ReqPhysicianSpeciality&quot;);
				tmpReqPhysicianDeliveryAddress     = sqlResult.getString(&quot;ReqPhysicianDeliveryAddress&quot;);
				tmpSugeryName                      = sqlResult.getString(&quot;SugeryName&quot;);
				tmpSurgeryCode                     = sqlResult.getString(&quot;SurgeryCode&quot;);
				tmpSurgeryAddress                  = sqlResult.getString(&quot;SurgeryAddress&quot;);
				tmpSurgeryPostalCode               = sqlResult.getString(&quot;SurgeryPostalCode&quot;);
				tmpCopyPhysicianIDList             = sqlResult.getString(&quot;CopyPhysicianIDList&quot;);
				tmpCopyPhysicianNameList           = sqlResult.getString(&quot;CopyPhysicianNameList&quot;);
				tmpPanelIndicator                  = sqlResult.getString(&quot;PanelIndicator&quot;);
				tmpPanelID                         = sqlResult.getString(&quot;PanelID&quot;);
				tmpPanelName                       = sqlResult.getString(&quot;PanelName&quot;);
				tmpSampleID                        = sqlResult.getString(&quot;SampleID&quot;);
				tmpSampleFluidType                 = sqlResult.getString(&quot;SampleFluidType&quot;);
				tmpSampleOriginLocation            = sqlResult.getString(&quot;SampleOriginLocation&quot;);
				tmpSampleOriginSubLocation         = sqlResult.getString(&quot;SampleOriginSubLocation&quot;);
				tmpSampleCollectionDateTime        = sqlResult.getString(&quot;SampleCollectionDateTime&quot;);
				tmpSampleCollectionMethod          = sqlResult.getString(&quot;SampleCollectionMethod&quot;);
				tmpTestSiteSampleReceivedDateTime  = sqlResult.getString(&quot;TestSiteSampleReceivedDateTime&quot;);
				tmpTestPriority                    = sqlResult.getString(&quot;TestPriority&quot;);
				tmpTestDepartment                  = sqlResult.getString(&quot;TestDepartment&quot;);
				tmpTestInstrument                  = sqlResult.getString(&quot;TestInstrument&quot;);
				tmpTestRequestSite                 = sqlResult.getString(&quot;TestRequestSite&quot;);
				tmpTestSite                        = sqlResult.getString(&quot;TestSite&quot;);
				tmpTestType                        = sqlResult.getString(&quot;TestType&quot;);
				tmpAbnormalFlag                    = sqlResult.getString(&quot;AbnormalFlag&quot;);
				tmpTestOrderedDateTime             = sqlResult.getString(&quot;TestOrderedDateTime&quot;);
				tmpTestAnalyzerCompletionDateTime  = sqlResult.getString(&quot;TestAnalyzerCompletionDateTime&quot;);
				tmpTestResultFirstReviewedDateTime = sqlResult.getString(&quot;TestResultFirstReviewedDateTime&quot;);
				tmpTestResultReleasedDateTime      = sqlResult.getString(&quot;TestResultReleasedDateTime&quot;);
				tmpEpisodeDate		= DateUtil.getDate(&quot;yyyy-MM-dd HH:mm:ss&quot;, tmpEpisodeDateTime).getTime();

				// Check whether we moved onto a different episode, if we did and it hadn&apos;t already been processed then send a new
				// case...
				if ((tmpEpisodeID != currEpisodeID)) {
					if ($(&apos;cases_from_most_recent_episode_only&apos;) != &apos;true&apos;) {
						if (currEpisodeID != &quot;&quot;) {
							if (currStatus == &quot;N&quot;) {
								var currPatient = {&quot;caseId&quot;: currEpisodeID , site: &quot;&quot;, episodes: []};
								currPatient.episodes = episodes;
								// We&apos;re putting the batchSeq into the JSON message, the destination channel can split this out for use later
								// This is used for updating the records once the records are successfully sent to the web service
								var currMessage = {&quot;batchSeq&quot;: batchSeq, &quot;episodeID&quot;: currEpisodeID, Patient: currPatient};
								var json = JSON.stringify(currPatient);
								logger.trace(&quot;JSON Routing to REST CLIENT: &quot; + json);
								// Send the JSON Object to the Web Service channel
								resp = router.routeMessage(&quot;Rest Client&quot;, JSON.stringify(currMessage));
								if (resp) {
									logger.trace(&quot;Response from REST Channel: &quot; + resp.getMessage());
								}
							}
						}
					}
					
					episodeSize = episodes.push({episodeDate: tmpEpisodeDate,
											episodeId: tmpEpisodeID,
											attributeWithValues: [{externalName: &quot;PID&quot;, name: &quot;PID&quot;, value: tmpPatientID},
															{externalName: &quot;BIRTHDATE&quot;, name: &quot;BIRTHDATE&quot;, value: tmpPatientDOB},
															{externalName: &quot;LASTNAME&quot;, name: &quot;LASTNAME&quot;, value: tmpPatientSurname},
															{externalName: &quot;EpisodeOrderedTests&quot;, name: &quot;EpisodeOrderedTests&quot;, value: tmpEpisodeOrderedTests},
															{externalName: &quot;Site&quot;, name: &quot;Site&quot;, value: tmpTestSite},
															{externalName: &quot;PatientFamilyName&quot;, name : &quot;PatientFamilyName&quot;, value: tmpPatientFamilyName},
															{externalName: &quot;PatientGivenName&quot;, name : &quot;PatientGivenName&quot;, value: tmpPatientGivenName},
															{externalName: &quot;PatientTitle&quot;, name : &quot;PatientTitle&quot;, value: tmpPatientTitle},
															{externalName: &quot;PatientSex&quot;, name : &quot;PatientSex&quot;, value: tmpPatientSex},
															{externalName: &quot;PatientStreetAddress&quot;, name : &quot;PatientStreetAddress&quot;, value: tmpPatientStreetAddress},
															{externalName: &quot;PatientCity&quot;, name : &quot;PatientCity&quot;, value: tmpPatientCity},
															{externalName: &quot;PatientPostalCode&quot;, name : &quot;PatientPostalCode&quot;, value: tmpPatientPostalCode},
															{externalName: &quot;PatientState&quot;, name : &quot;PatientState&quot;, value: tmpPatientState},
															{externalName: &quot;PatientCountry&quot;, name : &quot;PatientCountry&quot;, value: tmpPatientCountry},
															{externalName: &quot;PatientStatus&quot;, name : &quot;PatientStatus&quot;, value: tmpPatientStatus},
															{externalName: &quot;PatientPregnancyFlag&quot;, name : &quot;PatientPregnancyFlag&quot;, value: tmpPatientPregnancyFlag},
															{externalName: &quot;PatientFastingFlag&quot;, name : &quot;PatientFastingFlag&quot;, value: tmpPatientFastingFlag}	,
															{externalName: &quot;PatientGivenName&quot;, name : &quot;externalName&quot;, value: tmpPatientGivenName},
															{externalName: &quot;EpisodeClinicalNotes&quot;, name: &quot;EpisodeClinicalNotes&quot;, value: tmpEpisodeClinicalNotes},
															{externalName: &quot;AccountType&quot;, name: &quot;AccountType&quot;, value: tmpAccountType},
															{externalName: &quot;AccountClass&quot;, name: &quot;AccountClass&quot;, value: tmpAccountClass},
															{externalName: &quot;BillTo&quot;, name: &quot;BillTo&quot;, value: tmpBillTo},
															{externalName: &quot;PatientPublicHealthIdentifier&quot;, name: &quot;PatientPublicHealthIdentifier&quot;, value: tmpPatientPublicHealthIdentifier},
															{externalName: &quot;EpisodePublicScheduleCode&quot;, name: &quot;EpisodePublicScheduleCode&quot;, value: tmpEpisodePublicScheduleCode},
															{externalName: &quot;PatientPrivateHealthFundName&quot;, name: &quot;PatientPrivateHealthFundName&quot;, value: tmpPatientPrivateHealthFundName},
															{externalName: &quot;PatientPrivateHealthFundID&quot;, name: &quot;PatientPrivateHealthFundID&quot;, value: tmpPatientPrivateHealthFundID},
															{externalName: &quot;ReqPhysicianID&quot;, name: &quot;ReqPhysicianID&quot;, value: tmpReqPhysicianID},
															{externalName: &quot;ReqPhysicianName&quot;, name: &quot;ReqPhysicianName&quot;, value: tmpReqPhysicianName},
															{externalName: &quot;ReqPhysicianSpeciality&quot;, name: &quot;ReqPhysicianSpeciality&quot;, value: tmpReqPhysicianSpeciality},
															{externalName: &quot;SugeryName&quot;, name: &quot;SugeryName&quot;, value: tmpSugeryName},
															{externalName: &quot;SurgeryCode&quot;, name: &quot;SurgeryCode&quot;, value: tmpSurgeryCode},
															{externalName: &quot;CopyPhysicianIDList&quot;, name: &quot;CopyPhysicianIDList&quot;, value: tmpCopyPhysicianIDList},
															{externalName: &quot;CopyPhysicianNameList&quot;, name: &quot;CopyPhysicianNameList&quot;, value: tmpCopyPhysicianNameList},
															{externalName: &quot;PanelIndicator&quot;, name: &quot;PanelIndicator&quot;, value: tmpPanelIndicator},
															{externalName: &quot;PanelID&quot;, name: &quot;PanelID&quot;, value: tmpPanelID},
															{externalName: &quot;PanelName&quot;, name: &quot;PanelName&quot;, value: tmpPanelName},
															{externalName: &quot;SampleID&quot;, name: &quot;SampleID&quot;, value: tmpSampleID},
															{externalName: &quot;SampleFluidType&quot;, name: &quot;SampleFluidType&quot;, value: tmpSampleFluidType},
															{externalName: &quot;SampleOriginLocation&quot;, name: &quot;SampleOriginLocation&quot;, value: tmpSampleOriginLocation},
															{externalName: &quot;SampleOriginSubLocation&quot;, name: &quot;SampleOriginSubLocation&quot;, value: tmpSampleOriginSubLocation},
															{externalName: &quot;SampleCollectionDateTime&quot;, name: &quot;SampleCollectionDateTime&quot;, value: tmpSampleCollectionDateTime},
															{externalName: &quot;SampleCollectionMethod&quot;, name: &quot;SampleCollectionMethod&quot;, value: tmpSampleCollectionMethod},
															{externalName: &quot;TestSiteSampleReceivedDateTime&quot;, name: &quot;TestSiteSampleReceivedDateTime&quot;, value: tmpTestSiteSampleReceivedDateTime},
															{externalName: &quot;TestPriority&quot;, name: &quot;TestPriority&quot;, value: tmpTestPriority},
															{externalName: &quot;TestRequestSite&quot;, name: &quot;TestRequestSite&quot;, value: tmpTestRequestSite},
															{externalName: &quot;TestSite&quot;, name: &quot;TestSite&quot;, value: tmpTestSite},
															{externalName: &quot;TestType&quot;, name: &quot;TestType&quot;, value: tmpTestType},
															{externalName: &quot;TestOrderedDateTime&quot;, name: &quot;TestOrderedDateTime&quot;, value: tmpTestOrderedDateTime},
															{externalName: &quot;TestResultReleasedDateTime&quot;, name: &quot;TestResultReleasedDateTime&quot;, value: tmpTestResultReleasedDateTime}]});
				}

				currEpisodeID		= tmpEpisodeID;
				currStatus		= sqlResult.getString(&quot;Processed_YN&quot;);

				tmpTestLISCode		= sqlResult.getString(&quot;TestLISCode&quot;);
				tmpTestLISName		= sqlResult.getString(&quot;TestLISName&quot;);
				tmpTestValue		= sqlResult.getString(&quot;TestValue&quot;);
				tmpTestNormalRange	= sqlResult.getString(&quot;TestNormalRange&quot;);
				tmpTestUnits		= sqlResult.getString(&quot;TestUnits&quot;);
				// batchSeq is only used when processing the records with a status of &quot;N&quot;
				// well actually the records will have a status of &quot;P&quot; for processing
				// but they haven&apos;t already beenprocessed
				batchSeq					= sqlResult.getInt(&quot;BatchSeq&quot;);
				episodes[episodeSize - 1].attributeWithValues.push({externalName: tmpTestLISCode, name: tmpTestLISName, value: tmpTestValue,
														units: tmpTestUnits, range: tmpTestNormalRange});

				/* For testing only. The API fails when sending the acxtual tests from the incoming messages*/
				//episodes[episodeSize - 1].attributeWithValues.push({externalName: &quot;GTT 120m&quot;, name: &quot;GTTP 120min&quot;, value: &quot;6.7&quot;});
				if (tmpPatientID != currPatientID){
					currPatientID = tmpPatientID;
				}
			} //end while
			channelMap.put(&apos;key3&apos;,DateUtil.getCurrentDate(&apos;HHmmss&apos;))
			if (currStatus == &quot;N&quot;) {				
				var currPatient = {&quot;caseId&quot;: currEpisodeID , site: &quot;&quot;, episodes: []};
				currPatient.episodes = episodes;
				var currMessage = {&quot;batchSeq&quot;: batchSeq, &quot;episodeID&quot;: currEpisodeID, Patient: currPatient};
				var json = JSON.stringify(currPatient);
				// Send the JSON Object to the Web Service
				logger.trace(&quot;JSON Routing to REST CLIENT: &quot; + json);
				resp = router.routeMessage(&quot;Rest Client DUP&quot;, JSON.stringify(currMessage));
				if (resp) {
					logger.trace(&quot;Response from REST Channel: &quot; + resp.getMessage());
				}
			}
			return true;
		}
	}
	catch(ex) {
		logger.error(&quot;PKS - Select_CDS_Data - Exception: &quot; + ex);
		throw ex;
	}
	finally {
	//	dbConn.close();
	}

}
</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.5.2">
            <id>db067561-3a9a-441d-bae4-516d34ae161a</id>
            <name>Select_CDS_Data_Dup2</name>
            <revision>3</revision>
            <lastModified>
              <time>1558435136043</time>
              <timezone>Europe/Paris</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function Select_CDS_Data_Dup2() {
	var currEpisodeID = &quot;&quot;;
	var currEpisode;
	var currPatientID = &quot;&quot;;
	var currStatus = &quot;&quot;;
	var episodes = [];
	var episodeSize = 0;
	var resp;

	var dbConn = Get_CDS_Connection();
	try {
		var sqlQuery = &quot;call rd_staging.rdSelCDSDataDup2()&quot;;
channelMap.put(&apos;key&apos;,DateUtil.getCurrentDate(&apos;HHmmss&apos;))
		var sqlResult = dbConn.executeCachedQuery(sqlQuery);
		channelMap.put(&apos;key2&apos;,DateUtil.getCurrentDate(&apos;HHmmss&apos;))
		// We can assume there will always be at least one row, even if there are no records to process
		// Let&apos;s check the result set
		var colCount = sqlResult.getMetaData().getColumnCount();
		// We&apos;re checking for the column count, if it is 2 then it&apos;s just a return code and message

		if (colCount == 2) {
			sqlResult.next();
			logger.trace(&quot;PKS - Select_CDS_Data - Info: &quot; + sqlResult.getString(&quot;Message&quot;));
			return false;
		} else {
			while (sqlResult.next()) {
				tmpEpisodeID		               = sqlResult.getString(&quot;EpisodeID&quot;);
				tmpEpisodeOrderedTests             = sqlResult.getString(&quot;EpisodeOrderedTests&quot;);
				tmpPatientID		               = sqlResult.getString(&quot;PatientID&quot;);
				tmpPatientSurname	               = sqlResult.getString(&quot;PatientFamilyName&quot;);
				tmpEpisodeDateTime   	          = sqlResult.getString(&quot;EpisodeDateTime&quot;);
				tmpPatientDOB		               = sqlResult.getString(&quot;PatientDOB&quot;);
				tmpTestSite		               = sqlResult.getString(&quot;TestSite&quot;);
				tmpPatientFamilyName               = sqlResult.getString(&quot;PatientFamilyName&quot;);
				tmpPatientGivenName                = sqlResult.getString(&quot;PatientGivenName&quot;);
				tmpPatientTitle                    = sqlResult.getString(&quot;PatientTitle&quot;);
				tmpPatientSex                      = sqlResult.getString(&quot;PatientSex&quot;);
				tmpPatientStreetAddress            = sqlResult.getString(&quot;PatientStreetAddress&quot;);
				tmpPatientCity                     = sqlResult.getString(&quot;PatientCity&quot;);
				tmpPatientPostalCode               = sqlResult.getString(&quot;PatientPostalCode&quot;);
				tmpPatientState                    = sqlResult.getString(&quot;PatientState&quot;);
				tmpPatientCountry                  = sqlResult.getString(&quot;PatientCountry&quot;);
				tmpPatientStatus                   = sqlResult.getString(&quot;PatientStatus&quot;);
				tmpPatientPregnancyFlag            = sqlResult.getString(&quot;PatientPregnancyFlag&quot;);
				tmpPatientFastingFlag              = sqlResult.getString(&quot;PatientFastingFlag&quot;);
				tmpEpisodeClinicalNotes            = sqlResult.getString(&quot;EpisodeClinicalNotes&quot;);
				tmpAccountType                     = sqlResult.getString(&quot;AccountType&quot;);
				tmpAccountClass                    = sqlResult.getString(&quot;AccountClass&quot;);
				tmpBillTo                          = sqlResult.getString(&quot;BillTo&quot;);
				tmpBillingAddress                  = sqlResult.getString(&quot;BillingAddress&quot;);
				tmpPatientPublicHealthIdentifier   = sqlResult.getString(&quot;PatientPublicHealthIdentifier&quot;);
				tmpEpisodePublicScheduleCode       = sqlResult.getString(&quot;EpisodePublicScheduleCode&quot;);
				tmpPatientPrivateHealthFundName    = sqlResult.getString(&quot;PatientPrivateHealthFundName&quot;);
				tmpPatientPrivateHealthFundID      = sqlResult.getString(&quot;PatientPrivateHealthFundID&quot;);
				tmpReqPhysicianID                  = sqlResult.getString(&quot;ReqPhysicianID&quot;);
				tmpReqPhysicianName                = sqlResult.getString(&quot;ReqPhysicianName&quot;);
				tmpReqPhysicianSpeciality          = sqlResult.getString(&quot;ReqPhysicianSpeciality&quot;);
				tmpReqPhysicianDeliveryAddress     = sqlResult.getString(&quot;ReqPhysicianDeliveryAddress&quot;);
				tmpSugeryName                      = sqlResult.getString(&quot;SugeryName&quot;);
				tmpSurgeryCode                     = sqlResult.getString(&quot;SurgeryCode&quot;);
				tmpSurgeryAddress                  = sqlResult.getString(&quot;SurgeryAddress&quot;);
				tmpSurgeryPostalCode               = sqlResult.getString(&quot;SurgeryPostalCode&quot;);
				tmpCopyPhysicianIDList             = sqlResult.getString(&quot;CopyPhysicianIDList&quot;);
				tmpCopyPhysicianNameList           = sqlResult.getString(&quot;CopyPhysicianNameList&quot;);
				tmpPanelIndicator                  = sqlResult.getString(&quot;PanelIndicator&quot;);
				tmpPanelID                         = sqlResult.getString(&quot;PanelID&quot;);
				tmpPanelName                       = sqlResult.getString(&quot;PanelName&quot;);
				tmpSampleID                        = sqlResult.getString(&quot;SampleID&quot;);
				tmpSampleFluidType                 = sqlResult.getString(&quot;SampleFluidType&quot;);
				tmpSampleOriginLocation            = sqlResult.getString(&quot;SampleOriginLocation&quot;);
				tmpSampleOriginSubLocation         = sqlResult.getString(&quot;SampleOriginSubLocation&quot;);
				tmpSampleCollectionDateTime        = sqlResult.getString(&quot;SampleCollectionDateTime&quot;);
				tmpSampleCollectionMethod          = sqlResult.getString(&quot;SampleCollectionMethod&quot;);
				tmpTestSiteSampleReceivedDateTime  = sqlResult.getString(&quot;TestSiteSampleReceivedDateTime&quot;);
				tmpTestPriority                    = sqlResult.getString(&quot;TestPriority&quot;);
				tmpTestDepartment                  = sqlResult.getString(&quot;TestDepartment&quot;);
				tmpTestInstrument                  = sqlResult.getString(&quot;TestInstrument&quot;);
				tmpTestRequestSite                 = sqlResult.getString(&quot;TestRequestSite&quot;);
				tmpTestSite                        = sqlResult.getString(&quot;TestSite&quot;);
				tmpTestType                        = sqlResult.getString(&quot;TestType&quot;);
				tmpAbnormalFlag                    = sqlResult.getString(&quot;AbnormalFlag&quot;);
				tmpTestOrderedDateTime             = sqlResult.getString(&quot;TestOrderedDateTime&quot;);
				tmpTestAnalyzerCompletionDateTime  = sqlResult.getString(&quot;TestAnalyzerCompletionDateTime&quot;);
				tmpTestResultFirstReviewedDateTime = sqlResult.getString(&quot;TestResultFirstReviewedDateTime&quot;);
				tmpTestResultReleasedDateTime      = sqlResult.getString(&quot;TestResultReleasedDateTime&quot;);
				tmpEpisodeDate		= DateUtil.getDate(&quot;yyyy-MM-dd HH:mm:ss&quot;, tmpEpisodeDateTime).getTime();

				// Check whether we moved onto a different episode, if we did and it hadn&apos;t already been processed then send a new
				// case...
				if ((tmpEpisodeID != currEpisodeID)) {
					if ($(&apos;cases_from_most_recent_episode_only&apos;) != &apos;true&apos;) {
						if (currEpisodeID != &quot;&quot;) {
							if (currStatus == &quot;N&quot;) {
								var currPatient = {&quot;caseId&quot;: currEpisodeID , site: &quot;&quot;, episodes: []};
								currPatient.episodes = episodes;
								// We&apos;re putting the batchSeq into the JSON message, the destination channel can split this out for use later
								// This is used for updating the records once the records are successfully sent to the web service
								var currMessage = {&quot;batchSeq&quot;: batchSeq, &quot;episodeID&quot;: currEpisodeID, Patient: currPatient};
								var json = JSON.stringify(currPatient);
								logger.trace(&quot;JSON Routing to REST CLIENT: &quot; + json);
								// Send the JSON Object to the Web Service channel
								resp = router.routeMessage(&quot;Rest Client&quot;, JSON.stringify(currMessage));
								if (resp) {
									logger.trace(&quot;Response from REST Channel: &quot; + resp.getMessage());
								}
							}
						}
					}
					
					episodeSize = episodes.push({episodeDate: tmpEpisodeDate,
											episodeId: tmpEpisodeID,
											attributeWithValues: [{externalName: &quot;PID&quot;, name: &quot;PID&quot;, value: tmpPatientID},
															{externalName: &quot;BIRTHDATE&quot;, name: &quot;BIRTHDATE&quot;, value: tmpPatientDOB},
															{externalName: &quot;LASTNAME&quot;, name: &quot;LASTNAME&quot;, value: tmpPatientSurname},
															{externalName: &quot;EpisodeOrderedTests&quot;, name: &quot;EpisodeOrderedTests&quot;, value: tmpEpisodeOrderedTests},
															{externalName: &quot;Site&quot;, name: &quot;Site&quot;, value: tmpTestSite},
															{externalName: &quot;PatientFamilyName&quot;, name : &quot;PatientFamilyName&quot;, value: tmpPatientFamilyName},
															{externalName: &quot;PatientGivenName&quot;, name : &quot;PatientGivenName&quot;, value: tmpPatientGivenName},
															{externalName: &quot;PatientTitle&quot;, name : &quot;PatientTitle&quot;, value: tmpPatientTitle},
															{externalName: &quot;PatientSex&quot;, name : &quot;PatientSex&quot;, value: tmpPatientSex},
															{externalName: &quot;PatientStreetAddress&quot;, name : &quot;PatientStreetAddress&quot;, value: tmpPatientStreetAddress},
															{externalName: &quot;PatientCity&quot;, name : &quot;PatientCity&quot;, value: tmpPatientCity},
															{externalName: &quot;PatientPostalCode&quot;, name : &quot;PatientPostalCode&quot;, value: tmpPatientPostalCode},
															{externalName: &quot;PatientState&quot;, name : &quot;PatientState&quot;, value: tmpPatientState},
															{externalName: &quot;PatientCountry&quot;, name : &quot;PatientCountry&quot;, value: tmpPatientCountry},
															{externalName: &quot;PatientStatus&quot;, name : &quot;PatientStatus&quot;, value: tmpPatientStatus},
															{externalName: &quot;PatientPregnancyFlag&quot;, name : &quot;PatientPregnancyFlag&quot;, value: tmpPatientPregnancyFlag},
															{externalName: &quot;PatientFastingFlag&quot;, name : &quot;PatientFastingFlag&quot;, value: tmpPatientFastingFlag}	,
															{externalName: &quot;PatientGivenName&quot;, name : &quot;externalName&quot;, value: tmpPatientGivenName},
															{externalName: &quot;EpisodeClinicalNotes&quot;, name: &quot;EpisodeClinicalNotes&quot;, value: tmpEpisodeClinicalNotes},
															{externalName: &quot;AccountType&quot;, name: &quot;AccountType&quot;, value: tmpAccountType},
															{externalName: &quot;AccountClass&quot;, name: &quot;AccountClass&quot;, value: tmpAccountClass},
															{externalName: &quot;BillTo&quot;, name: &quot;BillTo&quot;, value: tmpBillTo},
															{externalName: &quot;PatientPublicHealthIdentifier&quot;, name: &quot;PatientPublicHealthIdentifier&quot;, value: tmpPatientPublicHealthIdentifier},
															{externalName: &quot;EpisodePublicScheduleCode&quot;, name: &quot;EpisodePublicScheduleCode&quot;, value: tmpEpisodePublicScheduleCode},
															{externalName: &quot;PatientPrivateHealthFundName&quot;, name: &quot;PatientPrivateHealthFundName&quot;, value: tmpPatientPrivateHealthFundName},
															{externalName: &quot;PatientPrivateHealthFundID&quot;, name: &quot;PatientPrivateHealthFundID&quot;, value: tmpPatientPrivateHealthFundID},
															{externalName: &quot;ReqPhysicianID&quot;, name: &quot;ReqPhysicianID&quot;, value: tmpReqPhysicianID},
															{externalName: &quot;ReqPhysicianName&quot;, name: &quot;ReqPhysicianName&quot;, value: tmpReqPhysicianName},
															{externalName: &quot;ReqPhysicianSpeciality&quot;, name: &quot;ReqPhysicianSpeciality&quot;, value: tmpReqPhysicianSpeciality},
															{externalName: &quot;SugeryName&quot;, name: &quot;SugeryName&quot;, value: tmpSugeryName},
															{externalName: &quot;SurgeryCode&quot;, name: &quot;SurgeryCode&quot;, value: tmpSurgeryCode},
															{externalName: &quot;CopyPhysicianIDList&quot;, name: &quot;CopyPhysicianIDList&quot;, value: tmpCopyPhysicianIDList},
															{externalName: &quot;CopyPhysicianNameList&quot;, name: &quot;CopyPhysicianNameList&quot;, value: tmpCopyPhysicianNameList},
															{externalName: &quot;PanelIndicator&quot;, name: &quot;PanelIndicator&quot;, value: tmpPanelIndicator},
															{externalName: &quot;PanelID&quot;, name: &quot;PanelID&quot;, value: tmpPanelID},
															{externalName: &quot;PanelName&quot;, name: &quot;PanelName&quot;, value: tmpPanelName},
															{externalName: &quot;SampleID&quot;, name: &quot;SampleID&quot;, value: tmpSampleID},
															{externalName: &quot;SampleFluidType&quot;, name: &quot;SampleFluidType&quot;, value: tmpSampleFluidType},
															{externalName: &quot;SampleOriginLocation&quot;, name: &quot;SampleOriginLocation&quot;, value: tmpSampleOriginLocation},
															{externalName: &quot;SampleOriginSubLocation&quot;, name: &quot;SampleOriginSubLocation&quot;, value: tmpSampleOriginSubLocation},
															{externalName: &quot;SampleCollectionDateTime&quot;, name: &quot;SampleCollectionDateTime&quot;, value: tmpSampleCollectionDateTime},
															{externalName: &quot;SampleCollectionMethod&quot;, name: &quot;SampleCollectionMethod&quot;, value: tmpSampleCollectionMethod},
															{externalName: &quot;TestSiteSampleReceivedDateTime&quot;, name: &quot;TestSiteSampleReceivedDateTime&quot;, value: tmpTestSiteSampleReceivedDateTime},
															{externalName: &quot;TestPriority&quot;, name: &quot;TestPriority&quot;, value: tmpTestPriority},
															{externalName: &quot;TestRequestSite&quot;, name: &quot;TestRequestSite&quot;, value: tmpTestRequestSite},
															{externalName: &quot;TestSite&quot;, name: &quot;TestSite&quot;, value: tmpTestSite},
															{externalName: &quot;TestType&quot;, name: &quot;TestType&quot;, value: tmpTestType},
															{externalName: &quot;TestOrderedDateTime&quot;, name: &quot;TestOrderedDateTime&quot;, value: tmpTestOrderedDateTime},
															{externalName: &quot;TestResultReleasedDateTime&quot;, name: &quot;TestResultReleasedDateTime&quot;, value: tmpTestResultReleasedDateTime}]});
				}

				currEpisodeID		= tmpEpisodeID;
				currStatus		= sqlResult.getString(&quot;Processed_YN&quot;);

				tmpTestLISCode		= sqlResult.getString(&quot;TestLISCode&quot;);
				tmpTestLISName		= sqlResult.getString(&quot;TestLISName&quot;);
				tmpTestValue		= sqlResult.getString(&quot;TestValue&quot;);
				tmpTestNormalRange	= sqlResult.getString(&quot;TestNormalRange&quot;);
				tmpTestUnits		= sqlResult.getString(&quot;TestUnits&quot;);
				// batchSeq is only used when processing the records with a status of &quot;N&quot;
				// well actually the records will have a status of &quot;P&quot; for processing
				// but they haven&apos;t already beenprocessed
				batchSeq					= sqlResult.getInt(&quot;BatchSeq&quot;);
				episodes[episodeSize - 1].attributeWithValues.push({externalName: tmpTestLISCode, name: tmpTestLISName, value: tmpTestValue,
														units: tmpTestUnits, range: tmpTestNormalRange});

				/* For testing only. The API fails when sending the acxtual tests from the incoming messages*/
				//episodes[episodeSize - 1].attributeWithValues.push({externalName: &quot;GTT 120m&quot;, name: &quot;GTTP 120min&quot;, value: &quot;6.7&quot;});
				if (tmpPatientID != currPatientID){
					currPatientID = tmpPatientID;
				}
			} //end while
			channelMap.put(&apos;key3&apos;,DateUtil.getCurrentDate(&apos;HHmmss&apos;))
			if (currStatus == &quot;N&quot;) {				
				var currPatient = {&quot;caseId&quot;: currEpisodeID , site: &quot;&quot;, episodes: []};
				currPatient.episodes = episodes;
				var currMessage = {&quot;batchSeq&quot;: batchSeq, &quot;episodeID&quot;: currEpisodeID, Patient: currPatient};
				var json = JSON.stringify(currPatient);
				// Send the JSON Object to the Web Service
				logger.trace(&quot;JSON Routing to REST CLIENT: &quot; + json);
				resp = router.routeMessage(&quot;Rest Client DUP2&quot;, JSON.stringify(currMessage));
				if (resp) {
					logger.trace(&quot;Response from REST Channel: &quot; + resp.getMessage());
				}
			}
			return true;
		}
	}
	catch(ex) {
		logger.error(&quot;PKS - Select_CDS_Data - Exception: &quot; + ex);
		throw ex;
	}
	finally {
	//	dbConn.close();
	}

}
</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.5.2">
            <id>a1da5ad8-2248-4f82-9042-5c4a968488ec</id>
            <name>Select_CDS_Data_Dup3</name>
            <revision>4</revision>
            <lastModified>
              <time>1558434871387</time>
              <timezone>Europe/Paris</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function Select_CDS_Data_Dup3() {
	var currEpisodeID = &quot;&quot;;
	var currEpisode;
	var currPatientID = &quot;&quot;;
	var currStatus = &quot;&quot;;
	var episodes = [];
	var episodeSize = 0;
	var resp;

	var dbConn = Get_CDS_Connection();
	try {
		var sqlQuery = &quot;call rd_staging.rdSelCDSDataDup_3()&quot;;
channelMap.put(&apos;key&apos;,DateUtil.getCurrentDate(&apos;HHmmss&apos;))
		var sqlResult = dbConn.executeCachedQuery(sqlQuery);
		channelMap.put(&apos;key2&apos;,DateUtil.getCurrentDate(&apos;HHmmss&apos;))
		// We can assume there will always be at least one row, even if there are no records to process
		// Let&apos;s check the result set
		var colCount = sqlResult.getMetaData().getColumnCount();
		// We&apos;re checking for the column count, if it is 2 then it&apos;s just a return code and message

		if (colCount == 2) {
			sqlResult.next();
			logger.trace(&quot;PKS - Select_CDS_Data - Info: &quot; + sqlResult.getString(&quot;Message&quot;));
			return false;
		} else {
			while (sqlResult.next()) {
				tmpEpisodeID		               = sqlResult.getString(&quot;EpisodeID&quot;);
				tmpEpisodeOrderedTests             = sqlResult.getString(&quot;EpisodeOrderedTests&quot;);
				tmpPatientID		               = sqlResult.getString(&quot;PatientID&quot;);
				tmpPatientSurname	               = sqlResult.getString(&quot;PatientFamilyName&quot;);
				tmpEpisodeDateTime   	          = sqlResult.getString(&quot;EpisodeDateTime&quot;);
				tmpPatientDOB		               = sqlResult.getString(&quot;PatientDOB&quot;);
				tmpTestSite		               = sqlResult.getString(&quot;TestSite&quot;);
				tmpPatientFamilyName               = sqlResult.getString(&quot;PatientFamilyName&quot;);
				tmpPatientGivenName                = sqlResult.getString(&quot;PatientGivenName&quot;);
				tmpPatientTitle                    = sqlResult.getString(&quot;PatientTitle&quot;);
				tmpPatientSex                      = sqlResult.getString(&quot;PatientSex&quot;);
				tmpPatientStreetAddress            = sqlResult.getString(&quot;PatientStreetAddress&quot;);
				tmpPatientCity                     = sqlResult.getString(&quot;PatientCity&quot;);
				tmpPatientPostalCode               = sqlResult.getString(&quot;PatientPostalCode&quot;);
				tmpPatientState                    = sqlResult.getString(&quot;PatientState&quot;);
				tmpPatientCountry                  = sqlResult.getString(&quot;PatientCountry&quot;);
				tmpPatientStatus                   = sqlResult.getString(&quot;PatientStatus&quot;);
				tmpPatientPregnancyFlag            = sqlResult.getString(&quot;PatientPregnancyFlag&quot;);
				tmpPatientFastingFlag              = sqlResult.getString(&quot;PatientFastingFlag&quot;);
				tmpEpisodeClinicalNotes            = sqlResult.getString(&quot;EpisodeClinicalNotes&quot;);
				tmpAccountType                     = sqlResult.getString(&quot;AccountType&quot;);
				tmpAccountClass                    = sqlResult.getString(&quot;AccountClass&quot;);
				tmpBillTo                          = sqlResult.getString(&quot;BillTo&quot;);
				tmpBillingAddress                  = sqlResult.getString(&quot;BillingAddress&quot;);
				tmpPatientPublicHealthIdentifier   = sqlResult.getString(&quot;PatientPublicHealthIdentifier&quot;);
				tmpEpisodePublicScheduleCode       = sqlResult.getString(&quot;EpisodePublicScheduleCode&quot;);
				tmpPatientPrivateHealthFundName    = sqlResult.getString(&quot;PatientPrivateHealthFundName&quot;);
				tmpPatientPrivateHealthFundID      = sqlResult.getString(&quot;PatientPrivateHealthFundID&quot;);
				tmpReqPhysicianID                  = sqlResult.getString(&quot;ReqPhysicianID&quot;);
				tmpReqPhysicianName                = sqlResult.getString(&quot;ReqPhysicianName&quot;);
				tmpReqPhysicianSpeciality          = sqlResult.getString(&quot;ReqPhysicianSpeciality&quot;);
				tmpReqPhysicianDeliveryAddress     = sqlResult.getString(&quot;ReqPhysicianDeliveryAddress&quot;);
				tmpSugeryName                      = sqlResult.getString(&quot;SugeryName&quot;);
				tmpSurgeryCode                     = sqlResult.getString(&quot;SurgeryCode&quot;);
				tmpSurgeryAddress                  = sqlResult.getString(&quot;SurgeryAddress&quot;);
				tmpSurgeryPostalCode               = sqlResult.getString(&quot;SurgeryPostalCode&quot;);
				tmpCopyPhysicianIDList             = sqlResult.getString(&quot;CopyPhysicianIDList&quot;);
				tmpCopyPhysicianNameList           = sqlResult.getString(&quot;CopyPhysicianNameList&quot;);
				tmpPanelIndicator                  = sqlResult.getString(&quot;PanelIndicator&quot;);
				tmpPanelID                         = sqlResult.getString(&quot;PanelID&quot;);
				tmpPanelName                       = sqlResult.getString(&quot;PanelName&quot;);
				tmpSampleID                        = sqlResult.getString(&quot;SampleID&quot;);
				tmpSampleFluidType                 = sqlResult.getString(&quot;SampleFluidType&quot;);
				tmpSampleOriginLocation            = sqlResult.getString(&quot;SampleOriginLocation&quot;);
				tmpSampleOriginSubLocation         = sqlResult.getString(&quot;SampleOriginSubLocation&quot;);
				tmpSampleCollectionDateTime        = sqlResult.getString(&quot;SampleCollectionDateTime&quot;);
				tmpSampleCollectionMethod          = sqlResult.getString(&quot;SampleCollectionMethod&quot;);
				tmpTestSiteSampleReceivedDateTime  = sqlResult.getString(&quot;TestSiteSampleReceivedDateTime&quot;);
				tmpTestPriority                    = sqlResult.getString(&quot;TestPriority&quot;);
				tmpTestDepartment                  = sqlResult.getString(&quot;TestDepartment&quot;);
				tmpTestInstrument                  = sqlResult.getString(&quot;TestInstrument&quot;);
				tmpTestRequestSite                 = sqlResult.getString(&quot;TestRequestSite&quot;);
				tmpTestSite                        = sqlResult.getString(&quot;TestSite&quot;);
				tmpTestType                        = sqlResult.getString(&quot;TestType&quot;);
				tmpAbnormalFlag                    = sqlResult.getString(&quot;AbnormalFlag&quot;);
				tmpTestOrderedDateTime             = sqlResult.getString(&quot;TestOrderedDateTime&quot;);
				tmpTestAnalyzerCompletionDateTime  = sqlResult.getString(&quot;TestAnalyzerCompletionDateTime&quot;);
				tmpTestResultFirstReviewedDateTime = sqlResult.getString(&quot;TestResultFirstReviewedDateTime&quot;);
				tmpTestResultReleasedDateTime      = sqlResult.getString(&quot;TestResultReleasedDateTime&quot;);
				tmpEpisodeDate		= DateUtil.getDate(&quot;yyyy-MM-dd HH:mm:ss&quot;, tmpEpisodeDateTime).getTime();

				// Check whether we moved onto a different episode, if we did and it hadn&apos;t already been processed then send a new
				// case...
				if ((tmpEpisodeID != currEpisodeID)) {
					if ($(&apos;cases_from_most_recent_episode_only&apos;) != &apos;true&apos;) {
						if (currEpisodeID != &quot;&quot;) {
							if (currStatus == &quot;N&quot;) {
								var currPatient = {&quot;caseId&quot;: currEpisodeID , site: &quot;&quot;, episodes: []};
								currPatient.episodes = episodes;
								// We&apos;re putting the batchSeq into the JSON message, the destination channel can split this out for use later
								// This is used for updating the records once the records are successfully sent to the web service
								var currMessage = {&quot;batchSeq&quot;: batchSeq, &quot;episodeID&quot;: currEpisodeID, Patient: currPatient};
								var json = JSON.stringify(currPatient);
								logger.trace(&quot;JSON Routing to REST CLIENT: &quot; + json);
								// Send the JSON Object to the Web Service channel
								resp = router.routeMessage(&quot;Rest Client&quot;, JSON.stringify(currMessage));
								if (resp) {
									logger.trace(&quot;Response from REST Channel: &quot; + resp.getMessage());
								}
							}
						}
					}
					
					episodeSize = episodes.push({episodeDate: tmpEpisodeDate,
											episodeId: tmpEpisodeID,
											attributeWithValues: [{externalName: &quot;PID&quot;, name: &quot;PID&quot;, value: tmpPatientID},
															{externalName: &quot;BIRTHDATE&quot;, name: &quot;BIRTHDATE&quot;, value: tmpPatientDOB},
															{externalName: &quot;LASTNAME&quot;, name: &quot;LASTNAME&quot;, value: tmpPatientSurname},
															{externalName: &quot;EpisodeOrderedTests&quot;, name: &quot;EpisodeOrderedTests&quot;, value: tmpEpisodeOrderedTests},
															{externalName: &quot;Site&quot;, name: &quot;Site&quot;, value: tmpTestSite},
															{externalName: &quot;PatientFamilyName&quot;, name : &quot;PatientFamilyName&quot;, value: tmpPatientFamilyName},
															{externalName: &quot;PatientGivenName&quot;, name : &quot;PatientGivenName&quot;, value: tmpPatientGivenName},
															{externalName: &quot;PatientTitle&quot;, name : &quot;PatientTitle&quot;, value: tmpPatientTitle},
															{externalName: &quot;PatientSex&quot;, name : &quot;PatientSex&quot;, value: tmpPatientSex},
															{externalName: &quot;PatientStreetAddress&quot;, name : &quot;PatientStreetAddress&quot;, value: tmpPatientStreetAddress},
															{externalName: &quot;PatientCity&quot;, name : &quot;PatientCity&quot;, value: tmpPatientCity},
															{externalName: &quot;PatientPostalCode&quot;, name : &quot;PatientPostalCode&quot;, value: tmpPatientPostalCode},
															{externalName: &quot;PatientState&quot;, name : &quot;PatientState&quot;, value: tmpPatientState},
															{externalName: &quot;PatientCountry&quot;, name : &quot;PatientCountry&quot;, value: tmpPatientCountry},
															{externalName: &quot;PatientStatus&quot;, name : &quot;PatientStatus&quot;, value: tmpPatientStatus},
															{externalName: &quot;PatientPregnancyFlag&quot;, name : &quot;PatientPregnancyFlag&quot;, value: tmpPatientPregnancyFlag},
															{externalName: &quot;PatientFastingFlag&quot;, name : &quot;PatientFastingFlag&quot;, value: tmpPatientFastingFlag}	,
															{externalName: &quot;PatientGivenName&quot;, name : &quot;externalName&quot;, value: tmpPatientGivenName},
															{externalName: &quot;EpisodeClinicalNotes&quot;, name: &quot;EpisodeClinicalNotes&quot;, value: tmpEpisodeClinicalNotes},
															{externalName: &quot;AccountType&quot;, name: &quot;AccountType&quot;, value: tmpAccountType},
															{externalName: &quot;AccountClass&quot;, name: &quot;AccountClass&quot;, value: tmpAccountClass},
															{externalName: &quot;BillTo&quot;, name: &quot;BillTo&quot;, value: tmpBillTo},
															{externalName: &quot;PatientPublicHealthIdentifier&quot;, name: &quot;PatientPublicHealthIdentifier&quot;, value: tmpPatientPublicHealthIdentifier},
															{externalName: &quot;EpisodePublicScheduleCode&quot;, name: &quot;EpisodePublicScheduleCode&quot;, value: tmpEpisodePublicScheduleCode},
															{externalName: &quot;PatientPrivateHealthFundName&quot;, name: &quot;PatientPrivateHealthFundName&quot;, value: tmpPatientPrivateHealthFundName},
															{externalName: &quot;PatientPrivateHealthFundID&quot;, name: &quot;PatientPrivateHealthFundID&quot;, value: tmpPatientPrivateHealthFundID},
															{externalName: &quot;ReqPhysicianID&quot;, name: &quot;ReqPhysicianID&quot;, value: tmpReqPhysicianID},
															{externalName: &quot;ReqPhysicianName&quot;, name: &quot;ReqPhysicianName&quot;, value: tmpReqPhysicianName},
															{externalName: &quot;ReqPhysicianSpeciality&quot;, name: &quot;ReqPhysicianSpeciality&quot;, value: tmpReqPhysicianSpeciality},
															{externalName: &quot;SugeryName&quot;, name: &quot;SugeryName&quot;, value: tmpSugeryName},
															{externalName: &quot;SurgeryCode&quot;, name: &quot;SurgeryCode&quot;, value: tmpSurgeryCode},
															{externalName: &quot;CopyPhysicianIDList&quot;, name: &quot;CopyPhysicianIDList&quot;, value: tmpCopyPhysicianIDList},
															{externalName: &quot;CopyPhysicianNameList&quot;, name: &quot;CopyPhysicianNameList&quot;, value: tmpCopyPhysicianNameList},
															{externalName: &quot;PanelIndicator&quot;, name: &quot;PanelIndicator&quot;, value: tmpPanelIndicator},
															{externalName: &quot;PanelID&quot;, name: &quot;PanelID&quot;, value: tmpPanelID},
															{externalName: &quot;PanelName&quot;, name: &quot;PanelName&quot;, value: tmpPanelName},
															{externalName: &quot;SampleID&quot;, name: &quot;SampleID&quot;, value: tmpSampleID},
															{externalName: &quot;SampleFluidType&quot;, name: &quot;SampleFluidType&quot;, value: tmpSampleFluidType},
															{externalName: &quot;SampleOriginLocation&quot;, name: &quot;SampleOriginLocation&quot;, value: tmpSampleOriginLocation},
															{externalName: &quot;SampleOriginSubLocation&quot;, name: &quot;SampleOriginSubLocation&quot;, value: tmpSampleOriginSubLocation},
															{externalName: &quot;SampleCollectionDateTime&quot;, name: &quot;SampleCollectionDateTime&quot;, value: tmpSampleCollectionDateTime},
															{externalName: &quot;SampleCollectionMethod&quot;, name: &quot;SampleCollectionMethod&quot;, value: tmpSampleCollectionMethod},
															{externalName: &quot;TestSiteSampleReceivedDateTime&quot;, name: &quot;TestSiteSampleReceivedDateTime&quot;, value: tmpTestSiteSampleReceivedDateTime},
															{externalName: &quot;TestPriority&quot;, name: &quot;TestPriority&quot;, value: tmpTestPriority},
															{externalName: &quot;TestRequestSite&quot;, name: &quot;TestRequestSite&quot;, value: tmpTestRequestSite},
															{externalName: &quot;TestSite&quot;, name: &quot;TestSite&quot;, value: tmpTestSite},
															{externalName: &quot;TestType&quot;, name: &quot;TestType&quot;, value: tmpTestType},
															{externalName: &quot;TestOrderedDateTime&quot;, name: &quot;TestOrderedDateTime&quot;, value: tmpTestOrderedDateTime},
															{externalName: &quot;TestResultReleasedDateTime&quot;, name: &quot;TestResultReleasedDateTime&quot;, value: tmpTestResultReleasedDateTime}]});
				}

				currEpisodeID		= tmpEpisodeID;
				currStatus		= sqlResult.getString(&quot;Processed_YN&quot;);

				tmpTestLISCode		= sqlResult.getString(&quot;TestLISCode&quot;);
				tmpTestLISName		= sqlResult.getString(&quot;TestLISName&quot;);
				tmpTestValue		= sqlResult.getString(&quot;TestValue&quot;);
				tmpTestNormalRange	= sqlResult.getString(&quot;TestNormalRange&quot;);
				tmpTestUnits		= sqlResult.getString(&quot;TestUnits&quot;);
				// batchSeq is only used when processing the records with a status of &quot;N&quot;
				// well actually the records will have a status of &quot;P&quot; for processing
				// but they haven&apos;t already beenprocessed
				batchSeq					= sqlResult.getInt(&quot;BatchSeq&quot;);
				episodes[episodeSize - 1].attributeWithValues.push({externalName: tmpTestLISCode, name: tmpTestLISName, value: tmpTestValue,
														units: tmpTestUnits, range: tmpTestNormalRange});

				/* For testing only. The API fails when sending the acxtual tests from the incoming messages*/
				//episodes[episodeSize - 1].attributeWithValues.push({externalName: &quot;GTT 120m&quot;, name: &quot;GTTP 120min&quot;, value: &quot;6.7&quot;});
				if (tmpPatientID != currPatientID){
					currPatientID = tmpPatientID;
				}
			} //end while
			channelMap.put(&apos;key3&apos;,DateUtil.getCurrentDate(&apos;HHmmss&apos;))
			if (currStatus == &quot;N&quot;) {				
				var currPatient = {&quot;caseId&quot;: currEpisodeID , site: &quot;&quot;, episodes: []};
				currPatient.episodes = episodes;
				var currMessage = {&quot;batchSeq&quot;: batchSeq, &quot;episodeID&quot;: currEpisodeID, Patient: currPatient};
				var json = JSON.stringify(currPatient);
				// Send the JSON Object to the Web Service
				logger.trace(&quot;JSON Routing to REST CLIENT: &quot; + json);
				resp = router.routeMessage(&quot;Rest Client DUP3&quot;, JSON.stringify(currMessage));
				if (resp) {
					logger.trace(&quot;Response from REST Channel: &quot; + resp.getMessage());
				}
			}
			return true;
		}
	}
	catch(ex) {
		logger.error(&quot;PKS - Select_CDS_Data - Exception: &quot; + ex);
		throw ex;
	}
	finally {
	//	dbConn.close();
	}

}
</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.5.2">
            <id>6f972e07-5a81-4de6-928c-f0135dd43747</id>
            <name>Stop_File_Reader</name>
            <revision>1</revision>
            <lastModified>
              <time>1550770641347</time>
              <timezone>Europe/Paris</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function Change_State(Channel, State) {
	const threadSleepTime = 10000; // ten seconds
	const millisecondsPerMinute = 60000;
	const maxAttempts = ($(&apos;CDS_Max_Wait_Minutes&apos;) * millisecondsPerMinute) / threadSleepTime;

	var attempts = 0;
	var channelState;

	channelState = ChannelUtil.getChannelState(Channel);
	if (channelState == State) {
		logger.debug(&apos;Channel already &apos; + State + &apos; no need to change state.&apos;);
		return true;
	} else {
		// Channel is running, need to check whether there are records to process...
		if (State == &quot;Started&quot;){
			logger.info(&apos;Starting Channel: &apos; + Channel);
			ChannelUtil.startChannel(Channel);
		} else {
			logger.info(&apos;Stopping Channel: &apos; + Channel);
			ChannelUtil.stopChannel(Channel);
		}
		channelState = ChannelUtil.getChannelState(Channel);
		while ((channelState != State) &amp;&amp; (attempts &lt; maxAttempts)) {
			logger.debug(&quot;Waiting for channel &quot; + Channel);
			channelState = ChannelUtil.getChannelState(Channel);
			if (channelState != State) {
				java.lang.Thread.sleep(threadSleepTime);
			}

			attempts ++;
		}
		logger.debug(&apos;Channel &apos; + Channel + &apos; is &apos; + channelState);
		if (channelState == State) {
			logger.debug(&apos;Successfully changed state of &apos; + Channel);
			return true;
		} else {
			return false;
		}
	}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.5.2">
            <id>4c706164-e5b5-4de5-ab21-b0c64c8be231</id>
            <name>Update_CDS_Status</name>
            <revision>8</revision>
            <lastModified>
              <time>1554218776495</time>
              <timezone>Europe/Paris</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>CHANNEL_ATTACHMENT</contextType>
                <contextType>GLOBAL_POSTPROCESSOR</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
                <contextType>CHANNEL_UNDEPLOY</contextType>
                <contextType>GLOBAL_PREPROCESSOR</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>CHANNEL_BATCH</contextType>
                <contextType>CHANNEL_POSTPROCESSOR</contextType>
                <contextType>GLOBAL_UNDEPLOY</contextType>
                <contextType>CHANNEL_PREPROCESSOR</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function Update_CDS_Status(ResponseStatus, currBatchSeq, currEpisodeID) {
	logger.trace(&quot;Resp Status: &quot; + ResponseStatus);

	var cdsStatus;

    if (ResponseStatus != &quot;SENT&quot;) {
		cdsStatus = &quot;E&quot;;
		logger.trace(&quot;Response code from web service call was not SENT, response:&quot; + ResponseStatus);
		// Call the stored proc setting the status to &quot;E&quot; for the error cases
		var dbConn = Get_CDS_Connection();
		try {
			var returnValue = 1;
			var sqlQuery = &quot;call rd_staging.rdUpdCDSStatus(&quot; + currBatchSeq + &quot;,&apos;&quot; + currEpisodeID + &quot;&apos;,&apos;&quot; + cdsStatus + &quot;&apos;)&quot;;

			logger.trace(&quot;SQL &quot; + sqlQuery);

			var sqlResult = dbConn.executeCachedQuery(sqlQuery);
			if (sqlResult.next()) {
				logger.error(&quot;PKS - Update_CDS_Status - Info: &quot; + sqlResult.getString(&quot;Message&quot;));
			}
		} catch (exception) {
			logger.error(&quot;Error updating table with error result:  &quot;);
			exception.printStackTrace();
		} finally {
		//	dbConn.close();
		}
	}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.5.2">
            <id>48e5ef76-7237-472f-87d6-9b04d5f9d73f</id>
            <name>Update_CDS_StatusDup</name>
            <revision>2</revision>
            <lastModified>
              <time>1558397337552</time>
              <timezone>Europe/Paris</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function Update_CDS_StatusDup(ResponseStatus, currBatchSeq, currEpisodeID) {
	logger.trace(&quot;Resp Status: &quot; + ResponseStatus);

	var cdsStatus;

    if (ResponseStatus != &quot;SENT&quot;) {
		cdsStatus = &quot;E&quot;;
		logger.trace(&quot;Response code from web service call was not SENT, response:&quot; + ResponseStatus);
		// Call the stored proc setting the status to &quot;E&quot; for the error cases
		var dbConn = Get_CDS_Connection();
		try {
			var returnValue = 1;
			var sqlQuery = &quot;call rd_staging.rdUpdCDSStatusDup(&quot; + currBatchSeq + &quot;,&apos;&quot; + currEpisodeID + &quot;&apos;,&apos;&quot; + cdsStatus + &quot;&apos;)&quot;;

			logger.trace(&quot;SQL &quot; + sqlQuery);

			var sqlResult = dbConn.executeCachedQuery(sqlQuery);
			if (sqlResult.next()) {
				logger.error(&quot;PKS - Update_CDS_Status - Info: &quot; + sqlResult.getString(&quot;Message&quot;));
			}
		} catch (exception) {
			logger.error(&quot;Error updating table with error result:  &quot;);
			exception.printStackTrace();
		} finally {
		//	dbConn.close();
		}
	}
}</code>
            </properties>
          </codeTemplate>
          <codeTemplate version="3.5.2">
            <id>7deb66ed-ae5a-4ab6-830a-5fd343bd25ff</id>
            <name>Utilities</name>
            <revision>9</revision>
            <lastModified>
              <time>1554218776167</time>
              <timezone>Europe/Paris</timezone>
            </lastModified>
            <contextSet>
              <delegate>
                <contextType>GLOBAL_DEPLOY</contextType>
                <contextType>CHANNEL_DEPLOY</contextType>
                <contextType>SOURCE_FILTER_TRANSFORMER</contextType>
                <contextType>DESTINATION_RESPONSE_TRANSFORMER</contextType>
                <contextType>DESTINATION_DISPATCHER</contextType>
                <contextType>SOURCE_RECEIVER</contextType>
                <contextType>DESTINATION_FILTER_TRANSFORMER</contextType>
              </delegate>
            </contextSet>
            <properties class="com.mirth.connect.model.codetemplates.BasicCodeTemplateProperties">
              <type>FUNCTION</type>
              <code>function Escape_String(str) {
		// Replace the following...
		// &apos; - Single quote
		// &quot; - Double quote
		// % - Percent
		// _ - Underscore
		// ; - Semi colon
		// No need to replace carriage returns, linefeeds and tabs as the incoming file is tab separated and row terminators
		// are carriage returns and linefeeds
		return str ? String(str).replace(/(&apos;|&quot;|\%|\_|\;)/g, &apos;\\$1&apos;) : str;
		}

function transformTestValue(result) {
	if (result != null &amp;&amp; result != &apos;&apos;) {
		if (result.indexOf(&quot;,&quot;) &gt;= 0) {
			result = result.replace(/,/g, &quot;.&quot;);
		}
	}
	var indexStart = result.indexOf(&quot; *&quot;);
	if (indexStart &gt;= 1) {
		result = result.substring(0, indexStart);
	}
	return result;
}

function transformRange(range) {
	if (range != null &amp;&amp; range != &apos;&apos;) {
		if (range.indexOf(&quot;,&quot;) &gt;= 0) {
			range = range.replace(/,/g, &quot;.&quot;);
		}
		if (range.indexOf(&apos;&lt;&apos;) == 0) {
      		var minus = range.indexOf(&apos;-&apos;);
      		range = range.substring(0, minus);
    		}
    		if (range == &apos;0.1-&lt; 1&apos;) {
      		range = &apos;0.1-1&apos;;
    		}
    		if (range == &apos;0.6 - 0.6 - 0.9&apos;) {
    			range = &apos;0.6 - 0.9&apos;;
    		}
    		if (range.indexOf(&apos;Negativo-&apos;) &gt;= 0) {
      		range = range.replace(&apos;Negativo-&apos;, &apos;&apos;);
    		}
		var indexM = range.search(/M[:\.]/);
		var indexH = range.search(/H[:\.]/);
		
		var gender = channelMap.get(&apos;CDS PatientSex&apos;)

		if (indexM &gt;= 0 &amp;&amp; indexH &gt;=0) {
			if (gender == &apos;F&apos;) {
				if (indexM &gt; indexH) {
					range = range.substring(3, indexM-1)
				} else {
					range = range.substring(indexH+3, range.length);
				}
			} else if (gender == &apos;M&apos;) {
				if (indexM &gt; indexH) {
					range = range.substring(indexM+3, range.length);
				} else {
					range = range.substring(3, indexH-1)
				}			
			}
		}
		if (!isValidRange(range)) {
			logger.error(&quot;Invalid range dropped:  &quot; + range + &quot;.  Data was stored without the range.&quot;);
			range = &quot;&quot;;
		}
	}
	return range;
}

function isValidRange(range) {
	var regex_min_to_max = /([\s|-]{0,1}\d{1,6}(\.\d{1,3}){0,1})\s{0,1}-\s{0,1}(\d{1,6}(\.\d{1,3}){0,1}\s{0,1})/;
	var regex_less_than_greater_than = /(\s{0,1}[&lt;&gt;]={0,1}\s{0,3}-{0,1}\d{1,2}(\.\d{1,2}){0,1})/;
	if (regex_min_to_max.test(range) == true) {
		var matches = [];
		range.replace(regex_min_to_max, function(match, min, decimal1, max, decimal2) {
			matches.push({
				min: min.trim(),
				max: max.trim()
			});
		});
		for (var i = 0; i &lt; matches.length; i++) {
			if (parseFloat(matches[i].min) &gt; parseFloat(matches[i].max)) {
				return false;
			} else {
				return true;
			}
		}
	}
	return regex_less_than_greater_than.test(range);
}

function encryptString(originalValue) {
	encryptedValue = originalValue.replace(/0/g, &apos;q&apos;);
	encryptedValue = encryptedValue.replace(/1/g, &apos;w&apos;);
	encryptedValue = encryptedValue.replace(/2/g, &apos;e&apos;);
	encryptedValue = encryptedValue.replace(/3/g, &apos;r&apos;);
	encryptedValue = encryptedValue.replace(/4/g, &apos;t&apos;);
	encryptedValue = encryptedValue.replace(/5/g, &apos;y&apos;);
	encryptedValue = encryptedValue.replace(/6/g, &apos;u&apos;);
	encryptedValue = encryptedValue.replace(/7/g, &apos;i&apos;);
	encryptedValue = encryptedValue.replace(/8/g, &apos;o&apos;);
	encryptedValue = encryptedValue.replace(/9/g, &apos;p&apos;);
	encryptedValue = encryptedValue.replace(/q/g, &apos;a&apos;);
	encryptedValue = encryptedValue.replace(/w/g, &apos;s&apos;);
	encryptedValue = encryptedValue.replace(/e/g, &apos;d&apos;);
	encryptedValue = encryptedValue.replace(/r/g, &apos;f&apos;);
	encryptedValue = encryptedValue.replace(/t/g, &apos;g&apos;);
	encryptedValue = encryptedValue.replace(/y/g, &apos;h&apos;);
	encryptedValue = encryptedValue.replace(/u/g, &apos;j&apos;);
	encryptedValue = encryptedValue.replace(/i/g, &apos;k&apos;);
	encryptedValue = encryptedValue.replace(/o/g, &apos;l&apos;);
	encryptedValue = encryptedValue.replace(/p/g, &apos;z&apos;);
	encryptedValue = encryptedValue.replace(/a/g, &apos;x&apos;);
	encryptedValue = encryptedValue.replace(/s/g, &apos;c&apos;);
	encryptedValue = encryptedValue.replace(/d/g, &apos;v&apos;);
	encryptedValue = encryptedValue.replace(/f/g, &apos;b&apos;);
	encryptedValue = encryptedValue.replace(/g/g, &apos;n&apos;);
	encryptedValue = encryptedValue.replace(/h/g, &apos;m&apos;);
	encryptedValue = encryptedValue.replace(/j/g, &apos;9&apos;);
	encryptedValue = encryptedValue.replace(/k/g, &apos;8&apos;);
	encryptedValue = encryptedValue.replace(/l/g, &apos;7&apos;);
	encryptedValue = encryptedValue.replace(/z/g, &apos;6&apos;);
	encryptedValue = encryptedValue.replace(/x/g, &apos;5&apos;);
	encryptedValue = encryptedValue.replace(/c/g, &apos;4&apos;);
	encryptedValue = encryptedValue.replace(/v/g, &apos;3&apos;);
	encryptedValue = encryptedValue.replace(/b/g, &apos;2&apos;);
	encryptedValue = encryptedValue.replace(/n/g, &apos;1&apos;);
	encryptedValue = encryptedValue.replace(/m/g, &apos;0&apos;);
	encryptedValue = encryptedValue.replace(/0/g, &apos;q&apos;);
	encryptedValue = encryptedValue.replace(/1/g, &apos;w&apos;);
	encryptedValue = encryptedValue.replace(/2/g, &apos;e&apos;);
	encryptedValue = encryptedValue.replace(/3/g, &apos;r&apos;);
	encryptedValue = encryptedValue.replace(/4/g, &apos;t&apos;);
	encryptedValue = encryptedValue.replace(/5/g, &apos;y&apos;);
	encryptedValue = encryptedValue.replace(/6/g, &apos;u&apos;);
	encryptedValue = encryptedValue.replace(/7/g, &apos;i&apos;);
	encryptedValue = encryptedValue.replace(/8/g, &apos;o&apos;);
	encryptedValue = encryptedValue.replace(/9/g, &apos;p&apos;);
	encryptedValue = encryptedValue.replace(/m/g, &apos;a&apos;);
	encryptedValue = encryptedValue.replace(/n/g, &apos;s&apos;);
	encryptedValue = encryptedValue.replace(/b/g, &apos;d&apos;);
	encryptedValue = encryptedValue.replace(/v/g, &apos;f&apos;);
	encryptedValue = encryptedValue.replace(/c/g, &apos;g&apos;);
	encryptedValue = encryptedValue.replace(/x/g, &apos;h&apos;);
	encryptedValue = encryptedValue.replace(/z/g, &apos;j&apos;);
	encryptedValue = encryptedValue.replace(/l/g, &apos;k&apos;);
	encryptedValue = encryptedValue.replace(/k/g, &apos;l&apos;);
	encryptedValue = encryptedValue.replace(/j/g, &apos;z&apos;);
	encryptedValue = encryptedValue.replace(/h/g, &apos;x&apos;);
	encryptedValue = encryptedValue.replace(/g/g, &apos;c&apos;);
	encryptedValue = encryptedValue.replace(/f/g, &apos;v&apos;);
	encryptedValue = encryptedValue.replace(/d/g, &apos;b&apos;);
	encryptedValue = encryptedValue.replace(/s/g, &apos;n&apos;);
	encryptedValue = encryptedValue.replace(/a/g, &apos;m&apos;);
	encryptedValue = encryptedValue.replace(/p/g, &apos;9&apos;);
	encryptedValue = encryptedValue.replace(/o/g, &apos;8&apos;);
	encryptedValue = encryptedValue.replace(/i/g, &apos;7&apos;);
	encryptedValue = encryptedValue.replace(/u/g, &apos;6&apos;);
	encryptedValue = encryptedValue.replace(/y/g, &apos;5&apos;);
	encryptedValue = encryptedValue.replace(/t/g, &apos;4&apos;);
	encryptedValue = encryptedValue.replace(/r/g, &apos;3&apos;);
	encryptedValue = encryptedValue.replace(/e/g, &apos;2&apos;);
	encryptedValue = encryptedValue.replace(/w/g, &apos;1&apos;);
	encryptedValue = encryptedValue.replace(/q/g, &apos;0&apos;);
	return encryptedValue;
}

function calculate_age_in_years(dateOfBirth) {
	var today = new Date();
	var birthDate = new Date(dateOfBirth);
	var age = today.getFullYear() - birthDate.getFullYear();
	var m = today.getMonth() - birthDate.getMonth();
	if (m &lt; 0 || (m === 0 &amp;&amp; today.getDate() &lt; birthDate.getDate())) {
		age--;
	}
	return age;
}

function buildStringIfNotNull(value) {
	if (value == null || value == &apos;&apos;) {
		return null;
	}
	return &quot;&apos;&quot; + value + &quot;&apos;&quot;;
}

</code>
            </properties>
          </codeTemplate>
        </codeTemplates>
      </codeTemplateLibrary>
    </codeTemplateLibraries>
    <channelTags/>
  </exportData>
</channel>